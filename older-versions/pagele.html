<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2%3Ffamily=Lato:wght@400%3B700&amp;family=Roboto:wght@400%3B700&amp;family=Quicksand:wght@400%3B700&amp;family=Montserrat:wght@400%3B700&amp;display=swap.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        .hold-button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: background-color 0.2s;
        }
        
        .hold-button:active {
            background-color: #0056b3;
        }

        .sentence-info-container {
            display: flex;
            justify-content: space-between; /* Or other alignment as needed */
            align-items: center; /* Vertically align items */
        }
    </style>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Daily Pages</title>
</head>
<body>
    <div id="title">
        <p>Daily Pages</p>
        <div id="title-right">
            <img src="images/settings.png" id="settings"/> 
        </div>
    </div>

    <!-- Add settings drawer -->
    <div id="settings-drawer" class="drawer">
        <span id="close-drawer" class="close">&times;</span>
        <h2>Settings</h2>
        <div id="settings-options">
            <input type="text" id="user-name" placeholder="Email">
            <input type="password" id="user-password" placeholder="Password">
            <div id="login-singup" >
                <div id="login-button" class="options" >Login</div>
                <div id="signup-button" class="options" >Sign up</div>
            </div>
            <div id="available-pagele" class="options">Available pagele</div>
            <div id="userLanguages" class="options">Native Language</div>
            <select id="languageUserOptions" default="en" class="settings-select">
                <option value="en">English</option>
                <option value="es">Spanish</option> 
                <option value="fr">FranÃ§ais</option>
                <option value="de">Deutch</option>
                <option value="it">Italian</option>
            </select>
            
            <div id="points-display">Points: <span id="total-points">0</span></div>
        </div>
    </div>

    <div id="pagele-content">
        <!-- Pagele Selection Modal -->
        <div id="pagele-modal" class="modal">
                <span class="close">&times;</span>
                <h2>Select a Pagele</h2>
                <div id="pagele-list-container">
                    <div id="pagele-list"></div>
                </div>
        </div>
        
        <!-- Chapters Grid Modal -->
        <div id="chapters-modal" >
                <span id="close-chapters-modal" class="close">&times;</span>
                <h2>Chapters</h2>
                <div id="chapters-grid"></div>
        </div>
        
        <!-- Sentence Display Modal -->
        <div id="sentence-modal" class="modal">
                
                <div class="sentence-info-container">
                    <button id="translation-btn" class="hold-button"> Translate </button>
                    <h2 id="chapter-title">Chapter Title</h2>
                    <span id="close-modal" >&times;</span>
                </div>
                <div id="sentence-container" ></div>
                <div id="prediction-container" ></div>
                <div class="sentence-info-container">
                    <span id="sentence-counter">1/10</span>
                    <span id="points-display">Points: </span><span id="points">0</span>
                </div>
                <div id="actionButtons" >
                    <img id="prev-sentence" src="images/arrow-left.png" alt="prev-sentence"/>
                    <img id="record" src="images/recordingButton.png" alt="record icon"/>
                    
                    <img id="robot" src="images/robot_talk_white.png" alt="robot" data-speaking="false"/>
                    
                    
                    <img id="next-sentence" src="images/arrow-right.png" alt="next-sentence"/>
                    
                    <div id="recording-status">
                        <div class="status-spinner"></div>
                        <div class="status-message">Processing...</div>
                        <div class="timer">0.0s</div>
                    </div>
                </div>
                
        </div>

    </div>
<div id="fetching-data-status" style="
    display: none; 
    position: fixed; /* Fixed to cover viewport */
    top: 0; 
    left: 0; 
    right: 0; 
    bottom: 0; 
    background-color: rgba(0, 0, 0, 0.7); 
    /* Ensure it's using flex to center content, as per JS */
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    z-index: 2000; /* High z-index to be on top */
    color: white;
    ">
    <div class="status-spinner"></div> <!-- Reuse your existing spinner style if you have one -->
    <div class="status-message">Fetching data...</div>
</div>
    <script>
        let completedIndices = {};
        let pageleFilename = "";
        let pagele_language = 'en';
        const language_name_map = {
            'english': 'en',
            'espagnol': 'es',
            'espaÃ±ol': 'es',
            'spanish': 'es',
            'francais': 'fr',
            'franÃ§ais': 'fr',
            'french': 'fr',
            'deutsch': 'de',
            'german': 'de',
            'italian': 'it',
            'italiano': 'it'
        };
        const sentenceModal = document.getElementById('sentence-modal');
        const pageleModal = document.getElementById('pagele-modal');
        const sentenceElem = document.getElementById('sentence-container');
        const counterElem = document.getElementById('sentence-counter');
        const prevButton = document.getElementById('prev-sentence');
        const nextButton = document.getElementById('next-sentence');
        const statusIndicator = document.getElementById('recording-status');
        const timerElement = statusIndicator.querySelector('.timer');
        const prediction = document.getElementById('prediction-container');
        const pointsSpan = document.getElementById('points');
        const availablePagele = document.getElementById('available-pagele');
        const closeSentenceModalBtn = document.getElementById('close-modal');
        const chaptersModal = document.getElementById('chapters-modal');
        const recordBtn = document.getElementById('record');

        closeSentenceModalBtn.addEventListener('click', () => {
            sentenceModal.style.display = 'none';
            chaptersModal.style.display = 'block';
        });
        const closeChaptersModal = document.getElementById('close-chapters-modal');
        closeChaptersModal.addEventListener('click', () => {
            chaptersModal.style.display = 'none';
            pageleModal.style.display = 'block';
        });
        availablePagele.addEventListener('click', () => {
            requestPageleList();
        });

        let translated_text = "";
        let translate_down = false;

        // Add these variables to track authentication state
        let isLoggedIn = false;
        let userInfo = {
            username: '',
            points: 0
        };
        
        let currentRequestStartTime = null;
        let currentRequestTask = '';

        let timerInterval = null;
        let userPoints = 0;
        let ttsCache = {}; // Cache for TTS audio data
        let lastTtsRequestDetails = null; // Stores {text, lang} of the last TTS request
        
        function createWebSocketConnection() {
            const socket = new WebSocket('wss://carriertech.uk:8675');
            //const socket = new WebSocket('ws://localhost:8675');
            socket.addEventListener('open', (event) => {
                console.log('WebSocket connection established');
            });

            socket.addEventListener('error', (error) => {
                console.error('WebSocket error:', error);
            });

            socket.addEventListener('message', async (event) => {
                const fetchingDataStatusElement = document.getElementById('fetching-data-status');
                if (fetchingDataStatusElement) {
                    fetchingDataStatusElement.style.display = 'flex';
                }

                if (currentRequestStartTime !== null) {
                    const duration = performance.now() - currentRequestStartTime;
                    console.log(`WebSocket response for task '${currentRequestTask}' received in ${duration.toFixed(2)} ms`);
                    currentRequestStartTime = null; // Reset for the next request
                    currentRequestTask = '';
                }

                console.log("Type of event.data: ", typeof event.data, "Is Blob?", event.data instanceof Blob, "Is ArrayBuffer?", event.data instanceof ArrayBuffer);

                let jsonString;
                let parsedResponseObject; // Use a temporary variable for the parsed object

                if (event.data instanceof ArrayBuffer) {
                    console.log("Received ArrayBuffer, decoding...");
                    const decoder = new TextDecoder("utf-8");
                    jsonString = decoder.decode(event.data);
                } else if (event.data instanceof Blob) {
                    console.log("Received Blob, reading as text...");
                    try {
                        jsonString = await event.data.text(); // Await the promise
                    } catch (e) {
                        console.error("Error reading Blob as text:", e);
                        if (currentRequestTask === 'stt' && statusIndicator && statusIndicator.style.display !== 'none') {
                           clearInterval(timerInterval);
                           statusIndicator.style.display = 'none';
                           if (processingStartTime) processingStartTime = 0;
                        }
                        if (fetchingDataStatusElement) fetchingDataStatusElement.style.display = 'none';
                        return; // Early exit
                    }
                } else if (typeof event.data === 'string') {
                    console.log("Received string directly.");
                    jsonString = event.data;
                } else {
                    console.error("Received WebSocket message of unknown type:", event.data);
                    if (currentRequestTask === 'stt' && statusIndicator && statusIndicator.style.display !== 'none') {
                        clearInterval(timerInterval);
                        statusIndicator.style.display = 'none';
                        if (processingStartTime) processingStartTime = 0;
                    }
                    if (fetchingDataStatusElement) fetchingDataStatusElement.style.display = 'none';
                    return; // Early exit
                }

                // Now, parse the jsonString
                if (typeof jsonString === 'string') {
                    try {
                        parsedResponseObject = JSON.parse(jsonString);
                        // Successfully parsed, log it before assigning to 'response' for user's code
                        console.log("Received WebSocket message (parsed successfully):", parsedResponseObject);
                    } catch (e) {
                        console.error("Error parsing JSON string:", e);
                        console.error("Original string that failed parsing:", jsonString);
                        if (currentRequestTask === 'stt' && statusIndicator && statusIndicator.style.display !== 'none') {
                           clearInterval(timerInterval);
                           statusIndicator.style.display = 'none';
                           if (processingStartTime) processingStartTime = 0;
                        }
                        if (fetchingDataStatusElement) fetchingDataStatusElement.style.display = 'none';
                        return; // Early exit
                    }
                } else {
                    console.error("Could not convert event.data to a string for parsing.");
                    if (currentRequestTask === 'stt' && statusIndicator && statusIndicator.style.display !== 'none') {
                        clearInterval(timerInterval);
                        statusIndicator.style.display = 'none';
                        if (processingStartTime) processingStartTime = 0;
                    }
                    if (fetchingDataStatusElement) fetchingDataStatusElement.style.display = 'none';
                    return; // Early exit
                }
                
                const response = parsedResponseObject; // Assign to 'response' for compatibility with the rest of the user's code
                if (fetchingDataStatusElement) { 
                    fetchingDataStatusElement.style.display = 'none';
                }

                // Handle array response (direct pagele list)
                if (Array.isArray(response)) {
                    console.log('Received pagele list array directly');
                    displayPageleList(response);
                }
                // Handle success response with user data
                else if (response.status === "success" && response.hasOwnProperty('username')) {
                    // User authenticated successfully
                    handleAuthSuccess(response);
                } 
                // Handle token verification
                else if (response.type === 'token_verification_result') {
                    if (response.success) {
                        console.log('Token verification successful');
                        isLoggedIn = true;
                        
                        // Update UI for logged in state
                        if (response.user_data && response.user_data.username) {
                            userInfo.username = response.user_data.username;
                            if (response.user_data.points) {
                                userInfo.points = response.user_data.points;
                            }
                            
                            // Just store preferred language if available for translation
                            if (response.user_data.preferred_language) {
                                userInfo.preferredLanguage = response.user_data.preferred_language;
                            }
                        }
                        
                        updateAuthUI(true);
                        
                        // Check if user has a selected pagele
                        if (!response.user_data.selected_pagele) {
                            // Request available pageles
                            requestPageleList();
                        }
                    } else {
                        console.log('Token verification failed');
                        // Handle invalid token
                        localStorage.removeItem('token');
                        localStorage.removeItem('username');
                        handleInvalidToken();
                    }
                } else if (response.type === 'pagele_list') {
                    // Display the pagele selection modal with the list
                    displayPageleList(response.pagele_books);
                } else if (response.type === 'get_pagele') {
                    displayChaptersGrid(response);
                } else if (response.status === "error") {
                    
                } else if (response.hasOwnProperty('pred_sentence')) {
                    handlePredSentence(response);
                } else if (response.status === 'success' && response.hasOwnProperty('audio')) {
                    handleTTSResponse(response);
                } else if (response.hasOwnProperty('translated_words')) {
                    console.log("translated_text: ", response.translated_words);
                    if (translate_down) {
                        sentenceElem.innerHTML = response.translated_words;
                    }
                    translated_text = response.translated_words;
                            
                } else if (response && response.preferred_language && typeof response.preferred_language === 'string') {
                    userInfo.preferredLanguage = response.preferred_language;
                    console.log("Found preferred language in response:", response.preferred_language);
                    
                    // Update dropdown if available
                    const languageSelect = document.getElementById('languageUserOptions');
                    if (languageSelect) {
                        languageSelect.value = response.preferred_language;
                    }
                }
                

                
                // Hide recording status indicator when response received
                
                if (statusIndicator) {
                    // Stop and clear the timer
                    clearInterval(timerInterval);
                    const finalTime = ((Date.now() - processingStartTime) / 1000).toFixed(1);
                    if (timerElement) {
                        timerElement.textContent = `${finalTime}s`;
                    }
                    // Hide the status indicator
                    statusIndicator.style.display = 'none';
                }
            });
            return socket;
        }

        function sendSocketMessage(message) {
            const fetchingDataStatusElement = document.getElementById('fetching-data-status');
            if (fetchingDataStatusElement) {
                fetchingDataStatusElement.style.display = 'flex';
            }
            
            socket = createWebSocketConnection();
            
            socket.addEventListener('open', () => {
                    currentRequestStartTime = performance.now();
                    currentRequestTask = message.task || 'unknown_task';
                    socket.send(JSON.stringify(message));
                }, { once: true });
            
        }

        window.addEventListener('DOMContentLoaded', () => {
            
            // Check for stored token and username
            const storedToken = localStorage.getItem('token');
            const storedUsername = localStorage.getItem('username');
            console.log("storedToken: ", storedToken);
            console.log("storedUsername: ", storedUsername);
            
            if (storedToken) {
                sendSocketMessage({
                    task: "verify_token",
                    token: storedToken
                });
                
                // Pre-populate the username field in settings
                const userNameInput = document.getElementById('user-name');
                if (userNameInput && storedUsername) {
                    userNameInput.value = storedUsername;
                    userInfo.username = storedUsername;
                }
            } else {
                // If no token, redirect back to main page
                console.log("No token found, user should log in first");
                alert("Please log in from the main page first");
                window.location.href = "index.html";
            }
            
            // Set up login button handlers
            setupAuthHandlers();
        });
        
        // Function to handle successful authentication
        function handleAuthSuccess(response) {
            console.log("Auth success:", response);
            
            // Save token if provided
            if (response.token) {
                localStorage.setItem('token', response.token);
            }
            
            // Save username
            if (response.username) {
                localStorage.setItem('username', response.username);
                userInfo.username = response.username;
            }
            
            // Set logged in state
            isLoggedIn = true;
            
            // Update points if available
            if (response.points) {
                userInfo.points = response.points;
            }
            
            // Store preferred language if available
            if (response.preferred_language) {
                userInfo.preferredLanguage = response.preferred_language;
                console.log("Stored preferred language from auth:", response.preferred_language);
                
                // Update the language dropdown to match
                const languageSelect = document.getElementById('languageUserOptions');
                if (languageSelect) {
                    languageSelect.value = response.preferred_language;
                }
            }
            
            // Update UI
            updateAuthUI(true);
            
            // Request pagele list after successful login
            requestPageleList();
        }
        
        // Function to handle invalid token
        function handleInvalidToken() {
            isLoggedIn = false;
            updateAuthUI(false);
            
            // Show an alert and redirect to index page
            alert("Your session has expired. Please log in again.");
            window.location.href = "index.html";
        }
        
        // Update UI based on authentication state
        function updateAuthUI(isAuthenticated) {
            const userNameInput = document.getElementById('user-name');
            const passwordInput = document.getElementById('user-password');
            const loginSignupDiv = document.getElementById('login-singup');
            const pointsDisplay = document.getElementById('points');
            
            if (isAuthenticated) {
                // Show username in the input field
                if (userNameInput) userNameInput.value = userInfo.username;
                
                // Update points display
                if (pointsDisplay) pointsDisplay.textContent = userInfo.points;
                
                // Change login button to logout
                const loginButton = document.getElementById('login-button');
                if (loginButton) loginButton.textContent = "Logout";
                
                // Optionally hide password field and signup button when logged in
                if (passwordInput) passwordInput.style.display = 'none';
                const signupButton = document.getElementById('signup-button');
                if (signupButton) signupButton.style.display = 'none';
            } else {
                // Reset fields for login state
                if (userNameInput) userNameInput.value = '';
                if (passwordInput) {
                    passwordInput.value = '';
                    passwordInput.style.display = 'block';
                }
                
                // Reset buttons
                const loginButton = document.getElementById('login-button');
                if (loginButton) loginButton.textContent = "Login";
                
                const signupButton = document.getElementById('signup-button');
                if (signupButton) signupButton.style.display = 'block';
            }
        }
        
        // Set up authentication button handlers
        function setupAuthHandlers() {
            const loginButton = document.getElementById('login-button');
            const signupButton = document.getElementById('signup-button');
            
            if (loginButton) {
                loginButton.addEventListener('click', () => {
                    if (isLoggedIn) {
                        // Handle logout
                        localStorage.removeItem('token');
                        localStorage.removeItem('username');
                        isLoggedIn = false;
                        userInfo = { username: '', points: 0 };
                        updateAuthUI(false);
                        
                        alert("You have been logged out. Redirecting to main page...");
                        window.location.href = "index.html";
                    } else {
                        // Handle login
                        const username = document.getElementById('user-name').value;
                        const password = document.getElementById('user-password').value;
                        
                        if (!username || !password) {
                            alert("Please enter both username and password");
                            return;
                        }
                        
                        sendSocketMessage({
                            task: "login",
                            username: username,
                            password: password
                        });
                    }
                });
            }
            
            if (signupButton) {
                signupButton.addEventListener('click', () => {
                    const username = document.getElementById('user-name').value;
                    const password = document.getElementById('user-password').value;
                    
                    if (!username || !password) {
                        alert("Please enter both username and password");
                        return;
                    }
                    
                    sendSocketMessage({
                        task: "signup",
                        username: username,
                        password: password
                    });
                });
            }
        }

        // Function to request the list of available pageles
        function requestPageleList() {
            sendSocketMessage({
                task: "get_pagele_list",
                token: localStorage.getItem('token')
            });
        }

        // Function to display the pagele selection modal
        function displayPageleList(pageleBooks) {
            const pageleList = document.getElementById('pagele-list');
            pageleList.innerHTML = '';
            
            if (pageleBooks.length === 0) {
                pageleList.innerHTML = '<p>No pagele books available.</p>';
            } else {
                pageleBooks.forEach(pagele => {
                    const card = document.createElement('div');
                    card.className = 'pagele-card';
                    card.dataset.pageleId = pagele.filename;
                    
                    card.innerHTML = `
                        <img class="pagele-cover" src="${pagele.cover}" alt="${pagele.book_name} cover">
                        <div class="pagele-title">${pagele.book_name}</div>
                        <div class="pagele-language">${pagele.language}</div>
                    `;
                    
                    card.addEventListener('click', () => selectPagele(pagele.filename, pagele.language, 0));
                    pageleList.appendChild(card);
                });
            }
            
            showPageleModal();
        }

        // Function to show the pagele selection modal
        function showPageleModal() {
            pageleModal.style.display = 'block';
            sentenceModal.style.display = 'none';
        }

        // Function to hide the pagele selection modal
        function hidePageleModal() {
            const modal = document.getElementById('pagele-modal');
            modal.style.display = 'none';
        }

        // Function to select a pagele
        function selectPagele(pageleFilename, language, index) {
            pagele_language = language;
            sendSocketMessage({
                task: "init_pagele",
                pagele_filename: pageleFilename,
                language: language,
                index: index,
                token: localStorage.getItem('token')
            });
            console.log("Selected pagele:", pageleFilename);
            hidePageleModal();
        }

        // Function to display chapters in a grid
        function displayChaptersGrid(response) {
            pageleFilename = response.user_pagele.current_pagele;
            completedIndices = response.user_pagele.books[pageleFilename].completed_indices;
            console.log("completedIndices: ", completedIndices);
            const chaptersGrid = document.getElementById('chapters-grid');
            chaptersGrid.innerHTML = '';
            pagele_data = response.pagele_data;
            if (Object.keys(pagele_data).length === 0) {
                chaptersGrid.innerHTML = '<p>No chapters available.</p>';
            } else {
                Object.keys(pagele_data).forEach((chapter, index) => {
                    const card = document.createElement('div');
                    card.className = 'chapter-card';
                    card.dataset.chapterIndex = index;   
                    let chapterPoints = 0;
                    /*console.log("chapter: ", chapter);
                    //console.log("completedIndices[chapter]: ", completedIndices[chapter]);
                    Object.values(completedIndices[chapter]).forEach((points) => {
                 
                        console.log("points: ", points);
                        chapterPoints += points;
                    });*/
                    card.innerHTML = `
                        <div class="chapter-title">${chapter}</div>
                       
                    `;
                    // <div class="chapter-points">${chapterPoints} points</div>
                    
                    card.addEventListener('click', () => openSentenceModal(chapter, index, completedIndices[chapter]));
                    chaptersGrid.appendChild(card);
                });
            }
            
            showChaptersModal();
        }

        // Function to show the chapters modal
        function showChaptersModal() {
            const modal = document.getElementById('chapters-modal');
            modal.style.display = 'block';
        }

        // Function to hide the chapters modal
        function hideChaptersModal() {
            const modal = document.getElementById('chapters-modal');
            modal.style.display = 'none';
        }

        // Variables to track current sentence
        let currentChapter = null;
        let currentSentenceIndex = 0;
        let pagele_data = null;

        // Add these variables at the top of your script with other variables
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let currentAudio = null;
        let processingStartTime = 0;

        // Function to open the sentence modal for a chapter
        function openSentenceModal(chapter, chapterIndex, chapterPoints) {
            currentChapter = chapter;
            hideChaptersModal();

            currentSentenceIndex = 0;
            console.log("currentChapter: ", chapter);
            document.getElementById('chapter-title').textContent = chapter;

            
            
            // Set up the sentence display with points
            updateSentenceDisplay();
            
            const modal = document.getElementById('sentence-modal');
            modal.style.display = 'block';
            
            // Add event listeners for navigation buttons
            prevButton.addEventListener('click', showPreviousSentence);
            nextButton.addEventListener('click', showNextSentence);
            
            // Reset points display for this chapter session
        }

        // Function to update the displayed sentence
        function updateSentenceDisplay() {
            let sentences = pagele_data[currentChapter];
            if (sentences.length === 0) {
                sentenceElem.textContent = "No sentences available for this chapter.";
                counterElem.textContent = "0/0";
                prevButton.disabled = true;
                nextButton.disabled = true;
                return;
            }
            
            sentenceElem.textContent = sentences[currentSentenceIndex];
            counterElem.textContent = `${currentSentenceIndex + 1}/${sentences.length}`;
            
            // Get and display points for current sentence
            let sentencePoints = 0;
            console.log("completedIndices: ", completedIndices);
            console.log("currentChapter: ", completedIndices[currentChapter]);
            console.log("currentSentenceIndex: ", completedIndices[currentChapter][currentSentenceIndex]);
            if (completedIndices && 
                completedIndices[currentChapter] && 
                completedIndices[currentChapter][currentSentenceIndex] !== undefined) {
                sentencePoints = completedIndices[currentChapter][currentSentenceIndex];
                console.log("sentencePoints: ", sentencePoints);
            }
            
            // Update points display for current sentence
            if (pointsSpan) {
                pointsSpan.textContent = sentencePoints;
                console.log("pointsSpan updated with: ", sentencePoints);
            } else {
                console.error("Points span element not found!");
            }
            
            // Add visual indicator for completed sentences
            if (sentencePoints > 0) {
                sentenceElem.classList.add('completed');
                if (sentencePoints >= 10) {
                    sentenceElem.classList.add('max-points');
                } else {
                    sentenceElem.classList.remove('max-points');
                }
            } else {
                sentenceElem.classList.remove('completed', 'max-points');
            }
            
            // Update button states
            prevButton.disabled = currentSentenceIndex === 0;
            nextButton.disabled = currentSentenceIndex === sentences.length - 1;
        }

        // Function to show the previous sentence
        function showPreviousSentence() {
            translated_text = "";
            prediction.innerHTML = "";
            if (currentSentenceIndex > 0) {
                currentSentenceIndex--;
                updateSentenceDisplay();
            }
        }

        // Function to show the next sentence
        function showNextSentence() {
            translated_text = "";
            prediction.innerHTML = "";
            if (currentSentenceIndex < pagele_data[currentChapter].length - 1) {
                currentSentenceIndex++;
                console.log("currentSentenceIndex: ", currentSentenceIndex);
                updateSentenceDisplay();
            }
        }

        // Function to close the sentence modal
        function closeSentenceModal() {
            const modal = document.getElementById('sentence-modal');
            modal.style.display = 'none';
            showChaptersModal();
        }

        // Add click event to close modals when clicking outside
        /*window.addEventListener('click', (event) => {
            const sentenceModal = document.getElementById('sentence-modal');
            const chaptersModal = document.getElementById('chapters-modal');
            const pageleModal = document.getElementById('pagele-modal');
            
            if (event.target === sentenceModal) {
                closeSentenceModal();
            } else if (event.target === chaptersModal) {
                hideChaptersModal();
            } else if (event.target === pageleModal) {
                hidePageleModal();
            }
        });*/

        // Function to handle prediction sentence response
        function handlePredSentence(response) {
            console.log("Received prediction:", response);
            
            const predSentence = response.pred_sentence;
            prediction.innerHTML = predSentence;
            // Add click handlers to wrong words
            document.querySelectorAll('.wrong').forEach(wrongWord => {
                wrongWord.addEventListener('click', (event) => {
                    // Get the correct word from the ID and speak it
                    const correctWord = wrongWord.id;
                    if (correctWord) {
                        textToSpeech(correctWord);
                    }
                });
            });
            
      
            pointsSpan.innerHTML = response.points;
            completedIndices[currentChapter][currentSentenceIndex] = response.points;
            
        }

      

        // Function to update timer during recording
        function updateTimer() {
            const timerElement = document.querySelector('.timer');
            if (timerElement && processingStartTime) {
                const elapsedTime = (Date.now() - processingStartTime) / 1000; // Convert to seconds
                timerElement.textContent = `${elapsedTime.toFixed(1)}s`;
            }
        }

        // NEW helper function to play audio data and manage UI
        function playAudioFromData(audioData, textKeyForLog) {
            console.log(`Playing audio for: ${textKeyForLog}`);
        
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
        
            const audio = new Audio(audioData);
            currentAudio = audio;
        
            const robotBtn = document.getElementById('robot');
            if (robotBtn) {
                robotBtn.setAttribute('data-speaking', 'true');
                robotBtn.style.filter = 'brightness(0.7)';
            }
        
            audio.onended = () => {
                console.log('Speech ended for:', textKeyForLog);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
        
            audio.onerror = (e) => {
                console.error('Speech error for:', textKeyForLog, e);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
        
            audio.play().catch(e => {
                console.error('Error playing audio for:', textKeyForLog, e);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null; 
            });
        }

        // Function to handle TTS responses
        function handleTTSResponse(response) {
            console.log("Received TTS response via WebSocket:", response);
        
            if (lastTtsRequestDetails && lastTtsRequestDetails.text && lastTtsRequestDetails.lang) {
                const cacheKey = `${lastTtsRequestDetails.lang}_${lastTtsRequestDetails.text}`;
                ttsCache[cacheKey] = response.audio;
                console.log('TTS: Cached audio for key:', cacheKey);
                
                playAudioFromData(response.audio, cacheKey);
            } else {
                console.warn('TTS: Received TTS response, but no lastTtsRequestDetails found. Cannot cache. Playing audio directly.');
                const fallbackKey = `unknown_${Date.now()}`;
                playAudioFromData(response.audio, fallbackKey);
            }
        }

        // Function to create blob and send to server
        function createBlobAndConnect() {
            const statusIndicator = document.getElementById('recording-status');
            if (statusIndicator) {
                statusIndicator.style.display = 'flex';
                // Start the timer
                processingStartTime = Date.now();
                updateTimer();
                timerInterval = setInterval(updateTimer, 100); // Update every 0.1 seconds
            }

            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            audioChunks = []; // Clear the chunks array for next recording

            // Convert blob to base64
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = function() {
                const base64data = reader.result;
                
                // Get the current sentence for comparison
                const currentSentence = sentenceElem.textContent;
                const language = pagele_language;
                if (language.length == 2) {
                    language = language_name_map[language];
                }
                sendSocketMessage({ 
                    task: 'stt', 
                    blob: base64data, 
                    language: language, 
                    sentence: currentSentence,
                    username: localStorage.getItem('username') || '',
                    book: pageleFilename, 
                    chapter: currentChapter,
                    currentSentenceIndex: currentSentenceIndex,
                    page: 'pagele'
                });
            };
        }

        // Function to speak the current sentence
        function textToSpeech(textToSpeak) {
            const lowerText = textToSpeak.toLowerCase();
            console.log('Requesting text-to-speech for:', lowerText, 'Original pagele_language:', pagele_language);
            
            let langForTTS = 'en'; // Default language code
            const currentRawPageleLang = pagele_language;
        
            if (currentRawPageleLang) {
                const lowerPageleLang = currentRawPageleLang.toLowerCase();
                if (language_name_map[lowerPageleLang]) {
                    langForTTS = language_name_map[lowerPageleLang];
                } else if (currentRawPageleLang.length === 2) { // Already a 2-letter code e.g. 'fr'
                    langForTTS = currentRawPageleLang;
                } else {
                    console.warn(`TTS: Unmapped/invalid pagele_language '${currentRawPageleLang}'. Using default '${langForTTS}'.`);
                }
            } else {
                console.warn(`TTS: pagele_language is not set. Using default '${langForTTS}'.`);
            }
            
            console.log('TTS: Using language code:', langForTTS, 'for text:', lowerText);
        
            const cacheKey = `${langForTTS}_${lowerText}`;
            const robotBtn = document.getElementById('robot');
        
            if (ttsCache[cacheKey]) {
                console.log('TTS: Playing from cache for key:', cacheKey);
                playAudioFromData(ttsCache[cacheKey], cacheKey);
                return;
            }
            
            console.log('TTS: Not in cache, requesting from server for key:', cacheKey);
            lastTtsRequestDetails = { text: lowerText, lang: langForTTS };
        
            if (robotBtn) {
                robotBtn.setAttribute('data-speaking', 'true');
                robotBtn.style.filter = 'brightness(0.7)';
            }
            
            sendSocketMessage({
                task: 'tts',
                text: lowerText,
                language: langForTTS
            });
        }

        // Add event listeners once DOM is loaded
        window.addEventListener('DOMContentLoaded', () => {
            // Record button event listener
            if (recordBtn) {
                recordBtn.addEventListener('click', async () => {
                    console.log("Recording button clicked");
                    try {
                        let permissionResult = await navigator.permissions.query({ name: 'microphone' });
                        
                        if (permissionResult.state === 'granted' || permissionResult.state === 'prompt') {
                            // Start/stop recording based on current state
                            if (!isRecording) {
                                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                                mediaRecorder = new MediaRecorder(stream);
                                
                                mediaRecorder.ondataavailable = event => {
                                    audioChunks.push(event.data);
                                };
                                
                                mediaRecorder.start();
                                isRecording = true;
                                if (mediaRecorder.state === 'recording') {
                                    console.log('Recording started successfully');
                                    recordBtn.src = "images/stopRecButton.png";
                                } else {
                                    alert('Failed to start recording. Please try again.');
                                    isRecording = false;
                                    recordBtn.src = "images/recordingButton.png";
                                }
                            } else {
                                mediaRecorder.stop();
                                isRecording = false;
                                recordBtn.src = "images/recordingButton.png";
                            }
                            
                            mediaRecorder.onstop = () => {
                                createBlobAndConnect();
                            };
                        } else if (permissionResult.state === 'denied') {
                            alert('Microphone permission is required for recording.');
                        }
                    } catch (error) {
                        console.error('Error accessing microphone:', error);
                        alert('Could not access microphone. Please check your browser permissions.');
                    }
                });
            }
            
            // Text-to-speech button event listener
            const robotBtn = document.getElementById('robot');
            if (robotBtn) {
                robotBtn.addEventListener('click', () => {
                    const isCurrentlySpeaking = robotBtn.getAttribute('data-speaking') === 'true';
                    
                    if (isCurrentlySpeaking) {
                        // Stop any currently playing audio
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio.currentTime = 0;
                            currentAudio = null;
                        }
                        
                        robotBtn.setAttribute('data-speaking', 'false');
                        robotBtn.style.filter = 'brightness(1)';
                    } else {
                        const currentSentence = sentenceElem.textContent;
                        robotBtn.setAttribute('data-speaking', 'true');
                        robotBtn.style.filter = 'brightness(0.7)';
                        textToSpeech(currentSentence);
                    }
                });
            }

            // Settings button event listener
            const settingsBtn = document.getElementById('settings');
            const drawer = document.getElementById('settings-drawer');
            const closeDrawerBtn = document.getElementById('close-drawer');
            
            settingsBtn.addEventListener('click', (event) => {
                console.log("settings button clicked");
                drawer.style.display = 'block';  // First set display to block
                setTimeout(() => {
                    drawer.classList.add('open'); // Then add the open class
                }, 10);
                event.stopPropagation();
            });
            
            closeDrawerBtn.addEventListener('click', () => {
                console.log("close button clicked");
                drawer.classList.remove('open');
                setTimeout(() => {
                    drawer.style.display = 'none';
                }, 300); // Wait for transition to complete
            });
            
            window.addEventListener('click', (event) => {
                // Check if the click was on the settings button or its children (like the image)
                if (!drawer.contains(event.target) && !settingsBtn.contains(event.target)) {
                    drawer.classList.remove('open');
                    setTimeout(() => {
                        drawer.style.display = 'none';
                    }, 300); // Wait for transition to complete
                }
            });
            
            // Make sure the drawer starts hidden
            drawer.style.display = 'none';

            // Add translation button functionality
            const translationBtn = document.getElementById('translation-btn');
            let originalSentence = '';
            
            if (translationBtn) {
                // Store original sentence when showing translation
                translationBtn.addEventListener('mousedown', handleTranslationStart);
                translationBtn.addEventListener('touchstart', handleTranslationStart);
                
                // Restore original sentence when button released
                translationBtn.addEventListener('mouseup', handleTranslationEnd);
                translationBtn.addEventListener('touchend', handleTranslationEnd);
                translationBtn.addEventListener('mouseleave', handleTranslationEnd);
                
                function handleTranslationStart(e) {
                    e.preventDefault(); // Prevent default behavior
                    translate_down = true;
                    originalSentence = sentenceElem.textContent;  
                    if (translated_text != "") {
                        sentenceElem.innerHTML = translated_text;
                    } else{
                        getTranslation(originalSentence);
                    }
                }
                
                function handleTranslationEnd() {
                    // Restore original sentence if we have one
                    translate_down = false;
                    if (originalSentence) {
                        sentenceElem.textContent = originalSentence;
                    }
                }
                
                function getTranslation(text) {
                    sentenceElem.textContent = "Translating...";
                    console.log("userInfo: ");
                    console.log(userInfo);
                    // Get user language from settings or from stored preferred language
                    let userLang = userInfo.preferredLanguage || document.getElementById('languageUserOptions').value || 'en';
                    
                    // Convert long language names to codes if needed
                    if (userLang.length > 2) {
                        const lowerLang = userLang.toLowerCase();
                        if (language_name_map[lowerLang]) {
                            userLang = language_name_map[lowerLang];
                        }
                    }
                    
                    // Handle source language (pagele_language) conversion if needed
                    let sourceLang = pagele_language;
                    if (sourceLang && sourceLang.length > 2) {
                        const lowerSource = sourceLang.toLowerCase();
                        if (language_name_map[lowerSource]) {
                            sourceLang = language_name_map[lowerSource];
                        }
                    }
                    
                    console.log("Using language for translation from", sourceLang, "to", userLang);
                    console.log({
                        task: 'translate',
                        text: text,
                        source_lang: sourceLang,
                        target_lang: userLang
                    });
                    // Send request for translation
                    sendSocketMessage({
                        task: 'translate',
                        text: text,
                        source_lang: sourceLang,
                        target_lang: userLang
                    });
                    
                    
                   
                }
            }
        });
    </script>
</body>
</html>
