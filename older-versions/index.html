<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto:wght@400;700&family=Quicksand:wght@400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet"> <!-- Include Lato, Roboto, and Montserrat fonts -->
<link rel="stylesheet" href="style.css">
<body>
    
    <div id="title">
        <p>Hablas</p>
        <img src="images/settings.png" id="settings"/> 
    </div>

    <div id="div2viewer">
        <div id="viewer-container">
            <button id="prev" class="side-nav-btn"><span>&laquo;</span></button>
            <div id="viewer">
                <div id="empty-viewer-message">
                    <p>No book loaded</p>
                    <button id="browse-books-btn">Browse Available Books</button>
                </div>
            </div> 
            <button id="next" class="side-nav-btn"><span>&raquo;</span></button>
        </div>
    </div>

    <div id="div3">
        
         
    </div>

    <input type="file" id="fileInput" accept=".epub"/>
     
    <div id="settings-drawer" class="drawer">
            <span id="close-drawer" class="close">&times;</span>
            <h2>Settings</h2>
            <div id="settings-options">
                <input type="text" id="user-name" placeholder="Email">
                <input type="password" id="user-password" placeholder="Password">
                <div id="login-singup" style="display: flex; width: 100%; gap: 10px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">
                    <div id="login-button" class="options" style="flex: 1;">Login</div>
                    <div id="signup-button" class="options" style="flex: 1;">Sign up</div>
                 </div>
                <div id="available-books" class="options">Available books</div>
                <div id="userLanguages"  class="options">Native Language</div>
                <select id="languageUserOptions" default="en" class="settings-select">
                    <option value="en">English</option>
                    <option value="es">Spanish</option> 
                    <option value="fr">Français</option>
                    <option value="de">Deutch</option>
                    <option value="it">Italian</option>
                </select>
                <div id="voice-gender" class="options">Voice Gender</div>
                <select id="voice-gender-select" class="settings-select">
                    <option value="female">Female</option>
                    <option value="male">Male</option>
                </select>
                <div id="points" class="options">Points</div>

                <div id="file">
                    <img src="images/upload-icon-white.png" alt="upload symbol" />
                    <img src="images/epub-icon-white.png" alt="upload symbol" />
                </div>
            </div>
    </div>


<div id="books-modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <div id="books-grid"></div>
    </div>
</div>

<div id="myModal" class="modal"> 
    <div class="modal-content"> 
        <span class="close-modal">&times;</span>
        <div id="modal-main">
            <div id="translation"></div>
            <div id="return_sentence"></div>
        </div>

        <div id="actionButtons">
            <img id="record" src="images/recordingButton.png" alt="record icon"/>
            <img id="robot" src="images/robot_talk_white.png" alt="robot"/>
        </div>
   
        <div id="bottom">
            <div class="bottom-row">
                <select id="language-select">
                    <option value="en">English</option>
                    <option value="es">Spanish</option> 
                    <option value="fr">Français</option>
                    <option value="de">Deutch</option>
                    <option value="it">Italian</option>
                </select>
            </div>
            <div class="bottom-row">
                <div id="points-display">Points Display: <span id="points">0</span></div>
            </div>
        </div>
        
        <!-- Add status indicator -->
        <div id="recording-status" style="display: none;">
            <div class="status-spinner"></div>
            <div class="status-message">Processing...</div>
        </div>
    </div>
</div>



<div id="user-account-options-modal" class="modal user-account-options-modal">
    <div class="modal-content user-account-options-modal-content">
        <span class="close options-close">&times;</span>
        <p>User account options</p>
        <button id="change-info-button">Change info</button>
        <button id="delete-account-button">Delete account</button>
    </div>
</div>

<div id="points-modal" class="modal"> 
    <div class="modal-content">
        <span class="close">&times;</span>
        <div class="points-container">
            <div class="points-row">
                <h3>Accumulated Points</h3>
                <p id="accumulated-points">0</p>
            </div>
            <div class="points-row">
                <h3>Points Left To Next Book</h3>
                <p id="current-points">0</p>
            </div>
        </div>
    </div>
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    fileInput.style.display= "none";
    let currentBook = null;
    let rendition = null;
    let selectedText = null;
    let lines = []; 
    let lineNum = 0;
    let language = "";
    let isRecording = false; 
    let translationText = "";
    let mediaRecorder; 
    let audioChunks = []; //buffer

    const lang_conversion = {
        "francais": "fr",
        "english": "en",
        "español": "es",
        "espagnol": "es",
        "spanish": "es",
        "deutsch": "de",
        "italiano": "it"
    }
    const modalDiv = document.getElementById('myModal');
    const closeBtn = document.getElementsByClassName('close')[0];
    
    const selectDiv = document.getElementById('selectedText');
    const prevArrowBtn = document.getElementsByClassName('arrowPrev')[0];
    const nextArrowBtn = document.getElementsByClassName('arrowNext')[0];
    const returnSentenceDiv = document.getElementById('return_sentence');
    const languageSel =document.getElementById('language-select');
    const fileDiv = document.getElementById("file");
    const pointsDisplay = document.getElementById("points-display");

    const nextPageBtn = document.getElementById('next');
    const prevPageBtn = document.getElementById('prev');
    const selectBtn = document.getElementById('select');

    const settingsBtn = document.getElementById ("settings");
    const drawer = document.getElementById('settings-drawer');
    const closeDrawerBtn = document.getElementById('close-drawer');
    const availableBooksBtn = document.getElementById('available-books');

    const recordBtn = document.getElementById('record'); 
    const textToSpeechBtn = document.getElementById('robot');
    const translation = document.getElementById('translation');
    
    const languageDisplay2 = document.getElementById('userLanguages');
    const languageUserOptionsSelect = document.getElementById('languageUserOptions');
    
    const abbreviations = [
        'Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Prof.',
        'Sr.', 'Jr.', 'etc.', 'e.g.', 'i.e.', '."'
    ];

    let socket = new WebSocket('wss://carriertech.uk:8675');; // Declare socket variable. Built-in object of js
    const booksModal = document.getElementById('books-modal');

    // First, get reference to your slider
    const speedSlider = document.querySelector('.vertical-slider'); // Adjust selector as needed
    let speechRate = 1; // Default speech rate
    let popupflag=false;
    // Add event listener to the slider
   
    const userAccountBtn = document.getElementById('user-account');
    const usernameInput = document.getElementById('user-name');
    const passwordInput = document.getElementById('user-password');
    const loginButton = document.getElementById ('login-button');
    const signupButton = document.getElementById ('signup-button');
    const forgotPasswordButton = document.getElementById ('forgot-password-button');
    const userAccountOptionsBtn = document.getElementById ('user-account-options');
    const changeInfoButton = document.getElementById ('change-info-button');
    const deleteAccountButton = document.getElementById ('delete-account-button');

    let username = '';
    let password = '';

    const voiceGenderDisplay = document.getElementById('voice-gender');
    const voiceGenderSelect = document.getElementById('voice-gender-select');
    let voiceGenderOptionsOpen = false;
    let availableVoices = [];
    let selectedVoiceGender = 'female'; // Default to female
    let selectedBook = null;
    let selectedPage = null;
    let sourceLang = "";

    const pointsBtn = document.getElementById('points');
    const pointsModal = document.getElementById('points-modal'); //outer modal !!
    const closePointsModalBtn = document.getElementById('close-points-modal');
    let currentPoints = 0;
    let pointsToNextBook = 100; //TO DO: get from server
 
console.log ("starting script");

// Add this function at the start of your script
function waitForEpub() {
    return new Promise((resolve, reject) => {
        if (typeof ePub !== 'undefined') {
            resolve();
        } else {
            // Check every 100ms for up to 5 seconds
            let attempts = 0;
            const interval = setInterval(() => {
                if (typeof ePub !== 'undefined') {
                    clearInterval(interval);
                    resolve();
                } else if (attempts >= 50) { // 5 seconds (50 * 100ms)
                    clearInterval(interval);
                    reject(new Error('ePub library failed to load'));
                }
                attempts++;
            }, 100);
        }
    });
}

// Replace the existing WebSocket implementation with a more structured approach
function createWebSocketConnection() {
    // Singleton instance
    let socketInstance = null;
    let isConnecting = false;
    let messageCallbacks = new Map();
    let connectionQueue = [];
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 1000; // Start with 1 second delay
    
    // Create a promise-based WebSocket request function
    async function makeWebSocketRequest(requestData) {
        console.log("makeWebSocketRequest: ", requestData);
        return new Promise(async (resolve, reject) => {
            try {
                // Generate a unique ID for this request
                const requestId = Date.now().toString() + Math.random().toString(36).substring(2, 15);
                requestData.id = requestId;
                
                // Ensure we have a connection
                const socket = await getSocket();
                
                // Register callback for this specific request
                messageCallbacks.set(requestId, (response) => {
                    resolve(response);
                    messageCallbacks.delete(requestId);
                });
                
                // Send the request
                socket.send(JSON.stringify(requestData));
                
                // Set timeout for request - increased to 60 seconds
                setTimeout(() => {
                    if (messageCallbacks.has(requestId)) {
                        messageCallbacks.delete(requestId);
                        reject(new Error("WebSocket request timed out"));
                        
                        // Try to reconnect if we have a timeout
                        if (socketInstance && socketInstance.readyState !== WebSocket.OPEN) {
                            reconnect();
                        }
                    }
                }, 60000); // 60 second timeout
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Reconnect function with exponential backoff
    function reconnect() {
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            console.error("Maximum reconnection attempts reached");
            return;
        }
        
        const delay = RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
        console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);
        
        setTimeout(() => {
            reconnectAttempts++;
            getSocket().catch(err => {
                console.error("Reconnection failed:", err);
            });
        }, delay);
    }
    
    // Get or create socket connection
    async function getSocket() {
        // If we already have a working connection, return it
        if (socketInstance && socketInstance.readyState === WebSocket.OPEN) {
            return socketInstance;
        }
        
        // If we're in the process of connecting, wait for it
        if (isConnecting) {
            return new Promise((resolve, reject) => {
                connectionQueue.push({ resolve, reject });
            });
        }
        
        // Start a new connection
        isConnecting = true;
        
        try {
            // Close existing socket if it exists
            if (socketInstance) {
                try {
                    socketInstance.close();
                } catch (e) {
                    console.log("Error closing existing socket:", e);
                }
            }
            
            // Create new connection
            socketInstance = new WebSocket('wss://carriertech.uk:8675');
            
            return new Promise((resolve, reject) => {
                // Set up event handlers
                socketInstance.addEventListener('open', () => {
                    console.log('WebSocket connection established');
                    isConnecting = false;
                    reconnectAttempts = 0; // Reset reconnect attempts on successful connection
                    
                    // Resolve this promise
                    resolve(socketInstance);
                    
                    // Resolve any queued promises
                    connectionQueue.forEach(queued => queued.resolve(socketInstance));
                    connectionQueue = [];
                });
                
                socketInstance.addEventListener('close', (event) => {
                    console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);
                    
                    // If we're still connecting, this is an error
                    if (isConnecting) {
                        isConnecting = false;
                        reject(new Error(`Failed to connect: ${event.code} ${event.reason}`));
                        
                        // Reject any queued promises
                        connectionQueue.forEach(queued => 
                            queued.reject(new Error(`Connection closed: ${event.code} ${event.reason}`))
                        );
                        connectionQueue = [];
                    }
                    
                    // Try to reconnect if this wasn't a normal closure
                    if (event.code !== 1000) {
                        reconnect();
                    }
                    
                    socketInstance = null;
                });
                
                socketInstance.addEventListener('error', (error) => {
                    console.error('WebSocket error:', error);
                    
                    // If we're still connecting, this is an error
                    if (isConnecting) {
                        isConnecting = false;
                        reject(error);
                        
                        // Reject any queued promises
                        connectionQueue.forEach(queued => queued.reject(error));
                        connectionQueue = [];
                    }
                });
                
                socketInstance.addEventListener('message', (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        console.log("Received WebSocket message:", response);
                        
                        const statusIndicator = document.getElementById('recording-status');
                        if (statusIndicator) {
                            statusIndicator.style.display = 'none';
                        }
                        
                        if (response.id && messageCallbacks.has(response.id)) {
                            messageCallbacks.get(response.id)(response);
                            return;
                        }
                        
                        if (response.books) {
                            handleBooksResponse(response);
                        } else if (response.hasOwnProperty('pred_sentence')) {
                            handlePredSentenceResponse(response);
                        } else if (response.hasOwnProperty('translation') || 
                                  (response.status === 'success' && response.hasOwnProperty('translated_text'))) {
                            handleTranslationResponse(response);
                        } else if (response.hasOwnProperty('token')) {
                            handleTokenResponse(response);
                        } else if (response.status === 'success' && response.hasOwnProperty('epub')) {
                            // Handle book data response
                            handleBookDataResponse(response);
                        } else if (response.message === "Invalid credentials") {
                            alert("Invalid credentials, have you signed up?");
                        } else {
                            console.log("Unhandled response from server:", response);
                        }
                    } catch (error) {
                        console.error("Error processing WebSocket message:", error);
                    }
                });
                
                // Set a connection timeout
                setTimeout(() => {
                    if (isConnecting) {
                        isConnecting = false;
                        reject(new Error("Connection timeout"));
                        
                        // Reject any queued promises
                        connectionQueue.forEach(queued => queued.reject(new Error("Connection timeout")));
                        connectionQueue = [];
                        
                        // Try to reconnect
                        reconnect();
                    }
                }, 10000); // 10 second connection timeout
            });
        } catch (error) {
            isConnecting = false;
            throw error;
        }
    }
    
    // Return the public API
    return {
        // Make a WebSocket request and get a response
        request: makeWebSocketRequest,
        
        // Get books from the server
        getBooks: async function() {
            return makeWebSocketRequest({ task: "get_books" });
        },
        
        // Translate text
        translate: async function(text, sourceLang, targetLang, book, page, username) {
            return makeWebSocketRequest({
                task: "translate",
                text: text,
                source_lang: sourceLang,
                target_lang: targetLang,
                current_book: book,
                page: page,
                username: username
            });
        },
        
        // Speech to text
        speechToText: async function(blob, language, sentence, username, book, page) {
            return makeWebSocketRequest({
                task: "stt",
                username: username,
                language: language,
                blob: blob,
                sentence: sentence,
                current_book: book,
                page: page
            });
        },
        
        // Login
        login: async function(username, password) {
            return makeWebSocketRequest({
                username: username,
                password: password,
                task: "login"
            });
        },
        signup: async function(username, password) {
            return makeWebSocketRequest({
                username: username,
                password: password,
                task: "signup"
            });
        },
        
        // Close the connection
        close: function() {
            if (socketInstance && socketInstance.readyState === WebSocket.OPEN) {
                socketInstance.close();
                socketInstance = null;
            }
        },
        
        // Check connection status
        isConnected: function() {
            return socketInstance && socketInstance.readyState === WebSocket.OPEN;
        },
        
        // Force reconnection
        forceReconnect: function() {
            reconnectAttempts = 0;
            return getSocket();
        },
        
        // Get specific book data
        getBookData: async function(filename, language) {
            return makeWebSocketRequest({
                task: "get_book_data",
                filename: filename,
                language: language
            });
        }
    };
}

// Create a single instance of the WebSocket connection manager
const wsConnection = createWebSocketConnection();

// Handler functions for different types of responses
function handleBooksResponse(response) {
    // Group books by language
    const booksByLanguage = response.books.reduce((acc, book) => {
        if (!acc[book.language]) {
            acc[book.language] = [];
        }
        acc[book.language].push(book);
        return acc;
    }, {});
    
   
    const booksGrid = document.getElementById('books-grid');
    booksGrid.innerHTML = '';
    
    Object.entries(booksByLanguage).forEach(([language, languageBooks]) => {
        const languageSection = document.createElement('div');
        languageSection.className = 'language-section';
        
        const languageHeader = document.createElement('h2');
        languageHeader.textContent = language.charAt(0).toUpperCase() + language.slice(1);
        languageSection.appendChild(languageHeader);
        
        const booksContainer = document.createElement('div');
        booksContainer.className = 'books-container';
        
        languageBooks.forEach(book => {
            const bookElement = document.createElement('div');
            bookElement.className = 'book';

            const img = document.createElement('img');
            // Check if cover is base64 data or path
            if (book.cover && book.cover.startsWith('data:')) {
                img.src = book.cover;
            } else {
                // Fallback to default cover if the base64 data is invalid
                img.src = 'images/default-cover.png';
                console.error('Invalid cover data for book:', book.filename);
            }
            img.alt = book.filename;
            
            const title = document.createElement('div');
            title.className = 'book-title';
            title.textContent = book.filename.replace('.epub', '');
            
            bookElement.appendChild(img);
            bookElement.appendChild(title);
            
            // Add click event to load the book (now using the async function)
            bookElement.addEventListener('click', async () => {
                try {
                    // Show loading indicator
                    title.textContent = "Loading...";
                    
                    // Request the specific book data
                    const response = await wsConnection.request({
                        task: "get_book_data",
                        filename: book.filename,
                    });
                    
                    if (response.error) {
                        throw new Error(response.error);
                    }
                    
                    if (!response.epub) {
                        throw new Error('No EPUB data received');
                    }
                    
                    const epubData = response.epub;
                    const base64Data = epubData.split(',')[1];
                    if (!base64Data) {
                        throw new Error('Invalid EPUB data format');
                    }
                    
                    const byteString = atob(base64Data);
                    const mimeString = epubData.split(',')[0].split(':')[1].split(';')[0];
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    const blob = new Blob([ab], {type: mimeString});
                    renderEpub(blob);
                    booksModal.style.display = 'none';
                    
                    languageSelect.value = setLanguage(langauge);
                    selectedBook = book.filename;
                    console.log("selected ", selectedBook);
                } catch (error) {
                    console.error('Error loading book:', error);
                    alert('Error loading book: ' + error.message);
                    
                    // Restore original title
                    title.textContent = book.filename.replace('.epub', '');
                }
            });
            
            booksContainer.appendChild(bookElement);
        });
        
        languageSection.appendChild(booksContainer);
        booksGrid.appendChild(languageSection);
    });
}

function setLanguage(language){
    if (lang_conversion[language]) {
        return lang_conversion[language];
    }else{
        return language;
    }
}
function handlePredSentenceResponse(response) {
    
    // Use a proper async function to handle this
    handlePredSentence(response.pred_sentence);
    
    // Add this to handle the points
    if (response.max_points !== undefined && response.total_points !== undefined) {
        // Add new points to current total
        currentPoints += response.total_points;
        console.log("Added points:", response.total_points);
        console.log("Current total points:", currentPoints);
        points_calculation(response.max_points, response.total_points);
    }
}

function handleTranslationResponse(response) {
    // Handle translation response
    const translatedText = response.translation || response.translated_text;
    translation.innerHTML = translatedText;
    console.log("Updated translation with:", translatedText);
}

function handleTokenResponse(response) {
    console.log("Token response:", response);
    localStorage.setItem('token', response.token);
    username = response.username;
    console.log("username: ", username);
    
    // Standardize the language code
    if (response.language) {

        sourceLang = response.language;
        console.log("Standardized language code:", sourceLang);
        
        // Update language selector if it exists
        if (languageSel) {
            languageSel.value = setLanguage(sourceLang);
            console.log("Updated languageSel value to:", languageSel.value);
        }
    }
    
    // Update UI to show logged-in state - pass the response object
    updateAuthUI(true, response.username, response);
    
    // Close the settings drawer
    drawer.classList.remove('open');
}

function updateAuthUI(isLoggedIn, username = '', responseData = null) {
    const loginSignupContainer = document.getElementById('login-singup');
    const usernameInput = document.getElementById('user-name');
    const passwordInput = document.getElementById('user-password');
    
    if (isLoggedIn) {
        // Hide login/signup elements
        loginSignupContainer.style.display = 'none';
        usernameInput.style.display = 'none';
        passwordInput.style.display = 'none';
        sourceLang = responseData.language;
        languageSel.value = setLanguage(sourceLang);
        console.log("sourceLang: ", sourceLang);
        // Add logged-in user display
        const userInfoDiv = document.createElement('div');
        userInfoDiv.id = 'user-info';
        userInfoDiv.className = 'options';
        userInfoDiv.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <span>Logged in as: ${username}</span>
                <button id="logout-button" class="small-button">Logout</button>
            </div>
        `;
        
        // Insert after the login elements
        const settingsOptions = document.getElementById('settings-options');
        settingsOptions.insertBefore(userInfoDiv, document.getElementById('available-books'));
        
        // Add logout functionality
        document.getElementById('logout-button').addEventListener('click', handleLogout);

        // Load user's current book if available - use responseData instead of response
        if (responseData && responseData.current_book && responseData.epub) {
            selectedBook = responseData.current_book;
            selectedPage = responseData.page || 0;
            language = responseData.language;
            console.log("Loading user's current book:", selectedBook);
            
            // Convert base64 to blob
            const base64Data = responseData.epub.split(',')[1];
            const mimeString = responseData.epub.split(',')[0].split(':')[1].split(';')[0];
            const byteString = atob(base64Data);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            
            // Render the book
            renderEpub(blob).then(() => {
                if (selectedPage && rendition) {
                    rendition.display(selectedPage);
                }
            }).catch(error => {
                console.error('Error rendering book:', error);
            });
        }
    } else {
        // Show login/signup elements
        loginSignupContainer.style.display = 'flex';
        usernameInput.style.display = 'block';
        passwordInput.style.display = 'block';
        
        // Remove user info if it exists
        const userInfo = document.getElementById('user-info');
        if (userInfo) {
            userInfo.remove();
        }
    }
}

function handleLogout() {
    // Clear stored token
    localStorage.removeItem('token');
    
    // Update UI
    updateAuthUI(false);
    
    // Reset any user-specific state
    username = '';
    password = '';
    
    // Close the settings drawer
    drawer.classList.remove('open');
}

// Update login button click handler
loginButton.addEventListener('click', async () => {
    loginButton.style.backgroundColor = '#FFB6C1';
    username = usernameInput.value;
    password = passwordInput.value;

    if (!isValidEmail(username)) {
        alert("Please enter a valid email address");
        return; 
    }

    if (!password || password.trim() === "") {
        alert("Password cannot be empty");
        return; 
    }

   
    const response = await wsConnection.login(username, password);
    console.log("Login response:", response);
    
    if (response.status === "success" && response.token) {
        localStorage.setItem('token', response.token);
        localStorage.setItem('username', username);
        
        // Update UI to show logged-in state
        updateAuthUI(true, username);
        
        // Close the settings drawer
        drawer.classList.remove('open');
    } else {
        alert(response.message || "Login failed. Please try again.");
    }
 
});

async function updateTranslation(text) {
    console.log(`Translating text: "${text}" from ${sourceLang}`);
    
    translation.textContent = "Translating...";
    
    // Get user's native language from settings
    const targetLang = languageUserOptionsSelect.value;
    console.log("targetLang: ", targetLang);
    console.log("sourceLang: ", sourceLang);
    console.log("username: ", username);
    try {
        // Check connection before sending
        if (!wsConnection.isConnected()) {
            translation.textContent = "Reconnecting...";
            await wsConnection.forceReconnect();
        }
        
        await wsConnection.translate(
            text, 
            sourceLang, 
            targetLang, 
            selectedBook, 
            selectedPage,
            username 
        );
    } catch (error) {
        console.error("Translation error:", error);
    }
}

// Update signup button click handler
signupButton.addEventListener('click', async () => {
    signupButton.style.backgroundColor = '#FFB6C1';
    username = usernameInput.value;
    password = passwordInput.value;

    if (!isValidEmail(username)) {
        alert("Please enter a valid email address");
        return;
    }

    if (!password || password.trim() === "") {
        alert("Password cannot be empty");
        return;
    }

    try {
        const response = await wsConnection.signup(username, password);
        console.log("Signup response:", response);
        
        if (response.status === "success" && response.token) {
            localStorage.setItem('token', response.token);
            localStorage.setItem('username', username);
            
            // Update UI to show logged-in state
            updateAuthUI(true, username);
            
            // Close the settings drawer
            drawer.classList.remove('open');
            
            alert("Account created successfully!");
        } else {
            alert(response.message || "Signup failed. Please try again.");
        }
    } catch (error) {
        console.error("Signup error:", error);
        alert("Signup failed. Please try again.");
    }
});

// Update token verification on page load
window.addEventListener('DOMContentLoaded', async () => {
    initializeVoices();
    
    // Check for stored token and username
    const storedToken = localStorage.getItem('token');
    const storedUsername = localStorage.getItem('username');
    console.log("storedToken: ", storedToken);
    console.log("storedUsername: ", storedUsername);
    
    if (storedToken) {
      
            // Ensure WebSocket connection is ready
            if (!wsConnection.isConnected()) {
                console.log("Reconnecting WebSocket...");
                await wsConnection.forceReconnect();
            }

            const response = await wsConnection.request({
                task: "verify_token",
                token: storedToken
            });
            
            if (response.status === "success") {
                username = response.username;
                updateAuthUI(true, username);
                
                if (response.current_book && response.epub) {
                    selectedBook = response.current_book;
                    selectedPage = response.page || 0;
                    console.log("Loading user's current book:", selectedBook);
                    
                    // Convert base64 to blob
                    const base64Data = response.epub.split(',')[1];
                    const mimeString = response.epub.split(',')[0].split(':')[1].split(';')[0];
                    const byteString = atob(base64Data);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    const blob = new Blob([ab], {type: mimeString});
                    
                    // Render the book
                    await renderEpub(blob);
                    if (selectedPage && rendition) {
                        rendition.display(selectedPage);
                    }
                }
                
                console.log("Auto-login successful");
            
       
    }}
});

// Initialize when the page loads
window.addEventListener('DOMContentLoaded', () => {
    initializeVoices();
    const storedToken = localStorage.getItem('token');
    if (!storedToken) {
        console.log("No stored token found");
        return;
    }
  
});

// Update the browse books button event listener
document.getElementById('browse-books-btn').addEventListener('click', () => {
    loadAvailableBooks();
    const booksModal = document.getElementById('books-modal');
    booksModal.style.display = 'block';
});

function loadAvailableBooks() {
    wsConnection.getBooks().catch(error => {
        console.error("Error loading books:", error);
    });
}

// Add this new function to handle the prediction sentence
async function handlePredSentence(predSentence) {
    console.log("predSentence: ", predSentence);
    returnSentenceDiv.innerHTML = predSentence;
    
    // Show points display
    const pointsDisplay = document.getElementById('points-display');
    pointsDisplay.style.display = 'block';
    
    // Count words
    const totalWords = predSentence.split(' ').length;
    const wrongWords = document.getElementsByClassName("wrong").length;
    const correctWords = totalWords - wrongWords;
    
    // Update points display with ratio
    const pointsElement = document.getElementById('points-display');
    pointsElement.textContent = `${correctWords}/${totalWords}`;
    
    // Optionally, store the points for later use
    userPoints = correctWords;
}

// Call loadAvailableBooks when the available books button is clicked
availableBooksBtn.addEventListener('click', () => {
    loadAvailableBooks();
    const booksModal = document.getElementById('books-modal');
    booksModal.style.display = 'block';
});

// Close books modal
document.querySelectorAll('.modal .close').forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        closeBtn.closest('.modal').style.display = 'none';
    });
});
    // Separate function for epub rendering
    async function renderEpub(file) {
        try {
            //await waitForEpub();
            
            currentBook = ePub(file);
            const viewer = document.getElementById("viewer");
            viewer.innerHTML = "";
            rendition = currentBook.renderTo("viewer", {
                height: "100%",
                width: "100%",
                allowScriptedContent: true,
                script: true,
                spread: "none",
                flow: "paginated",
                manager: "default"
            });
            
            rendition.display().then(() => {
                addClickHandlersToPage();
            });
            
            rendition.on("rendered", (section) => {
                selectedPage = section.href;
                addClickHandlersToPage();
            });
            
            // Function to add click handlers to the current page
            function addClickHandlersToPage() {
                const contents = rendition.getContents();
                
                contents.forEach(content => {
                    // Add click handlers to paragraphs and spans
                    content.document.querySelectorAll('p, span').forEach(element => {
                        // Skip if already processed
                        if (element.dataset.processed === "true") return;
                        
                        // Check if element has at least 2 words
                        const words = element.textContent.trim().split(/\s+/);
                        if (words.length < 2) return; // Skip elements with fewer than 2 words
                        
                        // Mark as processed to avoid duplicate handlers
                        element.dataset.processed = "true";
                        
                        // Create and add the select icon
                        const selectIcon = content.document.createElement('div');
                        selectIcon.innerHTML = `
                            <svg width="16" height="16" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="10" fill="#4588a0" fill-opacity="0.7"/>
                                <path d="M7 12h10" stroke="white" stroke-width="2"/>
                                <path d="M12 7v10" stroke="white" stroke-width="2"/>
                            </svg>`;
                        selectIcon.style.position = 'absolute';
                        selectIcon.style.left = '-3em';
                        selectIcon.style.top = '50%';
                        selectIcon.style.transform = 'translateY(-50%)';
                        selectIcon.style.zIndex = '5';
                        selectIcon.style.pointerEvents = 'none'; // Make sure icon doesn't interfere with clicks
                        
                        // Make the parent element relative for absolute positioning
                        element.style.position = 'relative';
                        element.style.paddingLeft = '8px';
                        element.style.marginLeft = '24px';
                        
                        // Insert the icon
                        element.insertBefore(selectIcon, element.firstChild);
                        
                        // Rest of the styles
                        element.style.cursor = 'pointer';
                        element.style.borderRadius = '3px';
                        element.style.transition = 'background-color 0.2s ease';
                        element.style.display = 'block';
                        
                        // Add hover effect
                        element.addEventListener('mouseover', () => {
                            element.style.backgroundColor = 'rgba(169, 209, 215, 0.3)';
                            const circleElement = selectIcon.querySelector('circle');
                            if (circleElement) {
                                circleElement.setAttribute('fill-opacity', '1');
                            }
                        });
                        
                        element.addEventListener('mouseout', () => {
                            if (!element.classList.contains('selected-line')) {
                                element.style.backgroundColor = 'transparent';
                                const circleElement = selectIcon.querySelector('circle');
                                if (circleElement) {
                                    circleElement.setAttribute('fill-opacity', '0.7');
                                }
                            }
                        });
                        
                        // Add click handler
                        element.addEventListener('click', (event) => {
                            console.log("Element clicked:", element.textContent.substring(0, 30) + "...");
                            
                            // Check if device is mobile
                            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                            console.log("Is mobile device:", isMobile);
                            
                            // Remove previous selection
                            content.document.querySelectorAll('.selected-line').forEach(el => {
                                el.classList.remove('selected-line');
                                el.style.backgroundColor = 'transparent';
                                const circleEl = el.querySelector('circle');
                                if (circleEl) {
                                    circleEl.setAttribute('fill-opacity', '0.7');
                                }
                            });
                            
                            // Add selection to clicked element
                            element.classList.add('selected-line');
                            element.style.backgroundColor = 'rgba(169, 209, 215, 0.5)';
                            const circleElement = selectIcon.querySelector('circle');
                            if (circleElement) {
                                circleElement.setAttribute('fill-opacity', '1');
                            }
                            
                            // Get element's bounding box relative to the window
                            const elementRect = element.getBoundingClientRect();
                            console.log("Element bounds:", {
                                top: elementRect.top,
                                bottom: elementRect.bottom,
                                height: elementRect.height
                            });
                            
                            // Position and show modal
                            const modal = document.getElementById('myModal');
                            const modalContent = modal.querySelector('.modal-content');
                            
                            if (modal) {
                                // Calculate position relative to viewport
                                const padding = isMobile ? 10 : 20; // Less padding on mobile
                                
                                // Get element's position relative to iframe
                                const elementRect = element.getBoundingClientRect();
                                console.log("Element position within iframe:", elementRect);
                                
                                // Get the iframe/viewer position relative to main window
                                const viewerContainer = document.getElementById('viewer-container');
                                const viewerRect = viewerContainer.getBoundingClientRect();
                                console.log("Viewer container position:", viewerRect);
                                
                                // Calculate absolute position by combining both
                                let absoluteTop = viewerRect.top + elementRect.top;
                                let absoluteBottom = viewerRect.top + elementRect.bottom;
                                
                                console.log("Calculated absolute position:", {
                                    top: absoluteTop,
                                    bottom: absoluteBottom
                                });
                                console.log("window.innerHeight: ", window.innerHeight);
                                console.log("window.innerWidth: ", window.innerWidth);
                                if ((absoluteBottom + modalContent.offsetHeight) > window.innerHeight) {
                                    absoluteBottom = absoluteTop - modalContent.offsetHeight - padding;
                                    if (absoluteBottom < 0) {
                                        absoluteBottom = absoluteTop;
                                    }
                                } else {
                                    absoluteBottom = absoluteBottom + padding;
                                }
                                // Reset all positioning to prevent any inherited styles
                                modal.style.cssText = `
                                    position: fixed !important;
                                    top: ${absoluteBottom}px !important;
                                    left: ${isMobile ? '10px' : ((window.innerWidth - (Math.min(window.innerWidth - 40, 800))) / 2) + 'px'} !important;
                                    display: block !important;
                                    z-index: 9999 !important;
                                    bottom: auto !important;
                                    transform: none !important;
                                    margin: 0 !important;
                                `;
                                
                                console.log("Modal style set to:", modal.style.cssText);
                                
                                // Set modal content width
                                if (isMobile) {
                                    modalContent.style.width = `calc(100vw - 20px)`;
                                    modalContent.style.maxWidth = '100%';
                                } else {
                                    const modalWidth = Math.min(window.innerWidth - 40, 800);
                                    modalContent.style.width = `${modalWidth}px`;
                                }
                                
                                // Ensure modal is visible by scrolling if necessary
                                setTimeout(() => {
                                    const modalHeight = modalContent.offsetHeight || 300;
                                    console.log("Modal actual dimensions:", {
                                        height: modalContent.offsetHeight,
                                        top: modal.getBoundingClientRect().top,
                                        bottom: modal.getBoundingClientRect().bottom
                                    });
                                    
                                    const modalBottom = absoluteBottom + padding + modalHeight;
                                    if (modalBottom  > window.innerHeight) {
                                        absoluteBottom = absoluteTop - modalContent.offsetHeight - padding;
                                        if (absoluteBottom < 0) {
                                            absoluteBottom = absoluteTop;
                                        }
                                        modal.style.top = `${absoluteBottom}px`;
                                    }
                                }, 50); // Short delay to ensure the modal has rendered
                                
                                // Get the text and update translation
                                selectedText = element.textContent.trim();
                                lines = [selectedText];
                                lineNum = 0;
                                
                                const translationDiv = document.getElementById('translation');
                                if (translationDiv) {
                                    updateTranslation(selectedText);
                                }
                                
                                // Prevent the click from propagating
                                event.stopPropagation();
                            }
                        });
                    });
                });
            }
            
            fileDiv.style.display = "none";
            
            
        } catch (error) {
            console.error('Error loading ePub:', error);
            alert('Error loading book. Please ensure you have a stable internet connection and try again.');
        }
    }

    recordBtn.addEventListener('click', async () => { //standarised procedure 
        if (!isRecording) {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); //built-in function of mozilla to get the media of the user
            mediaRecorder = new MediaRecorder(stream); //object pre-built
            
            mediaRecorder.ondataavailable = event => { //event = the object has changed in some way. every ms that you talk and it gets saved in the array
                audioChunks.push(event.data);  //saving the audio into an array
            };

            mediaRecorder.start();
            recordBtn.src = "images/stopRecButton.png";
            //socket.send(JSON.stringify({ event: 'start' })); // Notify server that recording has started
            isRecording=true;

         } else {   //this means that isRecording==true;
            mediaRecorder.stop(); 
            isRecording=false;
            recordBtn.src = "images/recordingButton.png";
         }        
        mediaRecorder.onstop = () => {
            createBlobAndConnect(); // Call the function to create the blob and connect
            //socket.send(JSON.stringify({ event: 'stop' })); // Notify server that recording has stopped
        };

       
    });

    const closeModalBtn = document.querySelector('.close-modal');

    // Add event listener for the new close button
    closeModalBtn.addEventListener('click', () => {
        modalDiv.style.display = "none";
        lineNum = 0;
        
        // Hide points display when modal closes
        const pointsDisplay = document.getElementById('points-display');
        pointsDisplay.style.display = 'none';
    });

    // Close modal when clicking outside
    window.addEventListener('click',(event)=> {
        if (event.target==modalDiv) {
            modalDiv.style.display = "none";
        }
    });

    fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
            try {
                await renderEpub(file);
            } catch (error) {
                console.error('Error handling file:', error);
            }
        }
    });

    fileDiv.addEventListener('click',()=> {
        fileInput.click();
    })

    settingsBtn.addEventListener('click',()=> {
        console.log("settings button clicked");
        drawer.classList.add('open'); //adding a class named 'open'
    });

    closeDrawerBtn.addEventListener('click', () => {
        drawer.classList.remove('open'); //removing a class named 'open'
    });

    window.addEventListener('click', (event) => {
        if (!drawer.contains(event.target) && event.target !== settingsBtn) {
            drawer.classList.remove('open');
        }
    });

    
    nextPageBtn.addEventListener('click', () => {
        console.log("nextPageBtn clicked");
        if (rendition) { //if an epub is loaded
            rendition.next().then(extractVisibleText); //next is a method from epub.js to go to the next page
        }
    })

    prevPageBtn.addEventListener('click',() =>{
        console.log("prevPageBtn clicked");
        if (rendition){
            rendition.prev().then(extractVisibleText);
        }
    } )

    textToSpeechBtn.addEventListener('click', () => {
        if ('speechSynthesis' in window) {
            textToSpeech(lines[lineNum]);
        } else {
            console.log("Sorry, your browser doesn't support text to speech!");
        }
    })
    
    
    function randomLanguage(){
        const languages = ['en', 'es', 'fr', 'de', 'it'];
        return languages[Math.floor(Math.random() * languages.length)];
    }

    function textToSpeech(textToSpeak) {
        if ('speechSynthesis' in window) {
            console.log('Starting text-to-speech for:', textToSpeak);
            
            let msg = new SpeechSynthesisUtterance();
            msg.text = textToSpeak;
            
            // Make sure we're using the correct language
            const currentLang = languageSel.value.substring(0,2);
            console.log('Using language:', currentLang);
            msg.lang = currentLang;
            
            // Match the settings from the robot button
            msg.rate = 1;
            msg.volume = 1;
            msg.pitch = 1;
            
            // Select a voice based on gender preference
            const voices = window.speechSynthesis.getVoices();
            
            // Filter voices by language and gender
            const matchingVoices = voices.filter(voice => {
                // Check if voice language matches or contains our target language
                const voiceLang = voice.lang.toLowerCase();
                const targetLang = currentLang.toLowerCase();
                const langMatch = voiceLang.startsWith(targetLang) || voiceLang.includes(targetLang);
                
                // Determine gender based on voice name (common pattern in voice APIs)
                // This is a heuristic and may not be 100% accurate
                const isFemaleName = voice.name.toLowerCase().includes('female') || 
                                   voice.name.toLowerCase().includes('woman') ||
                                   voice.name.toLowerCase().includes('girl') ||
                                   voice.name.toLowerCase().includes('fiona') ||
                                   voice.name.toLowerCase().includes('samantha') ||
                                   voice.name.toLowerCase().includes('victoria');
                                   
                const isMaleName = voice.name.toLowerCase().includes('male') || 
                                 voice.name.toLowerCase().includes('man') ||
                                 voice.name.toLowerCase().includes('guy') ||
                                 voice.name.toLowerCase().includes('david') ||
                                 voice.name.toLowerCase().includes('thomas') ||
                                 voice.name.toLowerCase().includes('daniel');
                
                // Match based on selected gender
                const genderMatch = (selectedVoiceGender === 'female' && isFemaleName) || 
                                  (selectedVoiceGender === 'male' && isMaleName);
                
                return langMatch && genderMatch;
            });
            
            console.log(`Found ${matchingVoices.length} matching voices for ${currentLang} and gender ${selectedVoiceGender}`);
            
            // Use the first matching voice, or fall back to default
            if (matchingVoices.length > 0) {
                msg.voice = matchingVoices[0];
                console.log("Selected voice:", msg.voice.name);
            } else {
                console.log("No matching voice found, using default");
            }
            
            // Add event listeners to debug TTS issues
            msg.onstart = () => console.log('Speech started');
            msg.onend = () => console.log('Speech ended');
            msg.onerror = (e) => console.error('Speech error:', e);
            
            window.speechSynthesis.speak(msg);
        } else {
            console.error("Speech synthesis not supported in this browser");
        }
    }
    
    function createPopup(content, event) {
        // Remove any existing popups first
        document.querySelectorAll('.popup').forEach(popup => popup.remove());
        
        const popup = document.createElement('div');
        const closePopupButton = document.createElement('span');
        const contentElement = document.createElement('p');
        
        // Style the close button
        closePopupButton.innerHTML = '&times;';
        closePopupButton.style.position = 'absolute';
        closePopupButton.style.top = '5px';
        closePopupButton.style.right = '10px';
        closePopupButton.style.cursor = 'pointer';
        closePopupButton.style.fontSize = '18px';
        closePopupButton.style.fontWeight = 'bold';
        closePopupButton.classList.add('popup-close');
        
        contentElement.textContent = content;
        
        popup.appendChild(contentElement);
        popup.appendChild(closePopupButton);
        
        closePopupButton.addEventListener('click', (e) => {
            popup.remove();
            popupflag = false;
            e.stopPropagation();
        });
        
        // Get click/touch position
        const x = event.clientX || (event.touches && event.touches[0].clientX) || 0;
        const y = event.clientY || (event.touches && event.touches[0].clientY) || 0;
        
        popup.style.position = 'absolute'; 
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`; 
        popup.classList.add('popup');
        
        document.body.appendChild(popup);
        popup.style.zIndex = 1000;
        
        // Fix: Call textToSpeech with the correct language
        if (content) {
            console.log("Speaking content:", content);
            textToSpeech(content);
        } else {
            console.error("No content to speak");
        }
        
        popupflag = true;
    }
    
    // Add a global click event listener to document
    document.addEventListener('click', (event) => {
        const popups = document.querySelectorAll('.popup');
        if (popups.length > 0) {
            // Check if the click was inside a popup or on a wrong element
            const clickedInsidePopup = Array.from(popups).some(popup => popup.contains(event.target));
            const clickedOnWrongElement = event.target.classList.contains('wrong');
            const clickedOnPopupClose = event.target.classList.contains('popup-close');
            
            // If clicked outside popup and not on a wrong element, remove all popups
            if (!clickedInsidePopup && !clickedOnWrongElement && !clickedOnPopupClose) {
                popups.forEach(popup => popup.remove());
                popupflag = false;
            }
        }
    });

    function openUserAccount() {
        document.getElementById('user-modal').style.display = 'block';
       }

    function initializeVoices() {
        // Get the available voices
        availableVoices = window.speechSynthesis.getVoices();
        
        // If voices aren't loaded yet, wait for them
        if (availableVoices.length === 0) {
            window.speechSynthesis.addEventListener('voiceschanged', () => {
                availableVoices = window.speechSynthesis.getVoices();
                console.log("Available voices:", availableVoices);
            }, { once: true }); // Add the 'once' option to only trigger this once
        } else {
            console.log("Available voices:", availableVoices);
        }
    }

    // Add event listener for voice gender selection
    voiceGenderDisplay.addEventListener('click', () => {
        if (voiceGenderOptionsOpen) {
            voiceGenderOptionsOpen = false;
            voiceGenderSelect.style.transform = 'translateX(1000%)';
        } else {
            voiceGenderSelect.style.transform = 'translateX(0)';
            voiceGenderOptionsOpen = true;
        }
    });

    // Update selected voice gender when changed
    voiceGenderSelect.addEventListener('change', () => {
        selectedVoiceGender = voiceGenderSelect.value;
        console.log("Selected voice gender:", selectedVoiceGender);
    });

    // Add event listener for text selection in the viewer
    const viewerElement = document.getElementById('viewer');
    if (viewerElement) {
        viewerElement.addEventListener('mouseup', handleTextSelection);
        viewerElement.addEventListener('touchend', handleTextSelection);
    }
    
    // Make sure language selection changes trigger retranslation
    languageSel.addEventListener('change', function() {
        if (translationText) {
            sourceLang = this.value;
            languageSel.value = setLanguage(sourceLang);
            updateTranslation(translationText);
        }
    });

    function handleTextSelection() {
        const selection = window.getSelection();
        const text = selection.toString().trim();
        
        if (text && text.length > 0) {
            console.log("Selected text:", text);
            selectedText = text;
            modalDiv.style.display = "block";
            sourceLang = languageSel.value;
            languageSel.value = setLanguage(sourceLang);
            translationText = text;
            updateTranslation(text);
        }
    }

    // Fix the extractVisibleText function to handle errors better
    function extractVisibleText() {
        console.log("extractVisibleText called");
        const location = rendition.currentLocation();
        console.log("Current location:", location);

        const makeRangeCfi = (a, b) => {
                const CFI = new ePub.CFI()
                const start = CFI.parse(a), end = CFI.parse(b)
                const cfi = {
                    range: true,
                    base: start.base,
                    path: {
                        steps: [],
                        terminal: null
                    },
                    start: start.path,
                    end: end.path
                }
                const len = cfi.start.steps.length
                for (let i = 0; i < len; i++) {
                    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
                        if (i == len - 1) {
                            if (cfi.start.terminal === cfi.end.terminal) {
                                cfi.path.steps.push(cfi.start.steps[i])
                                cfi.range = false
                            }
                        } else cfi.path.steps.push(cfi.start.steps[i])
                    } else break
                }
                cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)
                cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)

                return 'epubcfi(' + CFI.segmentString(cfi.base)
                    + '!' + CFI.segmentString(cfi.path)
                    + ',' + CFI.segmentString(cfi.start)
                    + ',' + CFI.segmentString(cfi.end)
                    + ')'
            }

        if (location && location.start && location.end) {
            const rangeCfi = makeRangeCfi(location.start.cfi, location.end.cfi);
            console.log("Range CFI created:", rangeCfi);
            
            currentBook.getRange(rangeCfi)
                .then(range => {
                    if (range) {
                        selectedText = range.toString();
                        console.log("Raw selected text:", selectedText);
                        
                        // Clean up text
                        selectedText = cleanText(selectedText);
                        console.log("Cleaned selected text:", selectedText);
                        
                        lines = selectedText.split('.')
                            .map(line => line.trim())
                            .filter(line => line.length > 0)
                            .map(line => line + '.');
                        
                        console.log("Lines array:", lines);
                        console.log("Number of lines:", lines.length);
                    } else {
                        console.log("Range is null or undefined");
                    }
                })
                .catch(error => {
                    console.error('Error getting range:', error);
                    // Initialize empty lines array to prevent further errors
                    lines = [];
                });
        } else {
            console.log("Location is invalid:", location);
        }
    }
    
    // Separate text cleaning function
    function cleanText(text) {
        const regexMatch = /[A-Z]\./g;
        text = text.replace(regexMatch, match => match.replace('.', ''));
        
        abbreviations.forEach(abbr => {
            let clean = abbr.replaceAll(".", "");
            text = text.replaceAll(abbr, clean);
        });
        
        return text;
    }

    function isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    // Add this function to handle book data responses
    function handleBookDataResponse(response) {
        if (response.error) {
            console.error('Error loading book:', response.error);
            alert('Error loading book: ' + response.error);
            return;
        }

        try {
            if (!response.epub) {
                throw new Error('No EPUB data received');
            }

            // Set selectedBook from the response filename
            selectedBook = response.filename;
            console.log("Set selectedBook:", selectedBook);

            // Set language from response
            sourceLang = response.language;
            languageSel.value = setLanguage(sourceLang);
            const base64Data = response.epub.split(',')[1];
            if (!base64Data) {
                throw new Error('Invalid EPUB data format');
            }

            const mimeString = response.epub.split(',')[0].split(':')[1].split(';')[0];
            const byteString = atob(base64Data);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            
            // Render the book
            renderEpub(blob).then(() => {
                if (response.page) {
                    rendition.display(response.page);
                }
                // Close the books modal if it's open
                const booksModal = document.getElementById('books-modal');
                if (booksModal) {
                    booksModal.style.display = 'none';
                }
            }).catch(error => {
                console.error('Error rendering book:', error);
                alert('Error rendering book: ' + error.message);
            });

        } catch (error) {
            console.error('Error processing book data:', error);
            alert('Error loading book: ' + error.message);
        }
    }

    function createBlobAndConnect() {
        // Show the recording status indicator
        const statusIndicator = document.getElementById('recording-status');
        if (statusIndicator) {
            statusIndicator.style.display = 'flex';
        }

        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        audioChunks = []; // Clear the chunks array for next recording

        // Convert blob to base64
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        reader.onloadend = async function() {
            const base64data = reader.result;
            
            // Log the current language value
            console.log("Current language value:", languageSel.value);
            console.log("Current sourceLang:", sourceLang);
            
            try {
              
                const response = await wsConnection.speechToText(
                    base64data,
                    languageSel.value,
                    lines[lineNum],
                    username,
                    selectedBook,
                    selectedPage
                );

                // Hide the recording status indicator
                if (statusIndicator) {
                    statusIndicator.style.display = 'none';
                }

                if (response.error) {
                    console.error('Speech to text error:', response.error);
                    alert('Error processing speech: ' + response.error);
                    return;
                }

                // Handle the response
                if (response.pred_sentence) {
                    handlePredSentence(response.pred_sentence);
                }

            } catch (error) {
                console.error('Error sending audio data:', error);
                
                // Hide the recording status indicator on error
                if (statusIndicator) {
                    statusIndicator.style.display = 'none';
                }
            }
        };
    }

    function points_calculation(max_points, total_points) { 
        try {
            console.log("points_calculation function called"); //debug
            // Update the points display
            const pointsElement = document.getElementById('points');
            if (pointsElement) {
                pointsElement.textContent = `${total_points}/${max_points}`;
            }

            // Update accumulated points display
            const accumulatedPoints = document.getElementById('accumulated-points');
            if (accumulatedPoints) {
                accumulatedPoints.textContent = currentPoints;
                console.log("Updated accumulated points display:", currentPoints);
            }

            // Make sure the points display is visible
            const pointsDisplay = document.getElementById('points-display');
            if (pointsDisplay) {
                pointsDisplay.style.display = 'block';
            }
        } catch (error) {
            console.error('Error updating points:', error);
        }
    }

    pointsBtn.addEventListener('click', () => {
        pointsModal.style.display = 'block';
        //currentPoints = 34; 
        pointsToNextBook = 100; //TO DO: get from server
        document.getElementById('accumulated-points').textContent = currentPoints;
        document.getElementById('current-points').textContent = pointsToNextBook; // Changed from 'point-to-next'
        
        console.log("Opening points modal:", {
            currentPoints,
            pointsToNextBook,
            modalDisplay: pointsModal.style.display
        });
    });

    closePointsModalBtn.addEventListener('click', () => {
        pointsModal.style.display = 'none';
    });

    window.addEventListener('click', (event) => {
        if (event.target === pointsModal) {
            pointsModal.style.display = 'none';
        }
    });

</script>
