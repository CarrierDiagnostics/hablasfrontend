<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto:wght@400;700&family=Quicksand:wght@400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet"> <!-- Include Lato, Roboto, and Montserrat fonts -->
<link rel="stylesheet" href="style.css">
<body>
    
    <div id="title">
        <p>Hablas</p>
        <img src="images/settings.png" id="settings"/> 
    </div>

    <div id="div2viewer">
        <div id="viewer-container">
            <button id="prev" class="side-nav-btn"><span>&laquo;</span></button>
            <div id="viewer">
                <div id="empty-viewer-message">
                    <p>No book loaded</p>
                    <button id="browse-books-btn">Browse Available Books</button>
                </div>
            </div> 
            <button id="next" class="side-nav-btn"><span>&raquo;</span></button>
        </div>
    </div>

    <div id="div3">
        
         
    </div>

    <input type="file" id="fileInput" accept=".epub"/>
     
    <div id="settings-drawer" class="drawer">
            <span id="close-drawer" class="close">&times;</span>
            <h2>Settings</h2>
            <div id="settings-options">
                <div id="available-books" class="options">Available books</div>
                <div id="userLanguages"  class="options">Native Language</div>
                <select id="languageUserOptions" default="en" class="settings-select">
                    <option value="en">English</option>
                    <option value="es">Spanish</option> 
                    <option value="fr">Fran√ßais</option>
                    <option value="deutch">Deutch</option>
                    <option value="it">Italian</option>
                </select>
                <div id="voice-gender" class="options">Voice Gender</div>
                <select id="voice-gender-select" class="settings-select">
                    <option value="female">Female</option>
                    <option value="male">Male</option>
                </select>

                <div id="file">
                    <img src="images/upload-icon-white.png" alt="upload symbol" />
                    <img src="images/epub-icon-white.png" alt="upload symbol" />
                </div>
            </div>
    </div>


<div id="books-modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <div id="books-grid"></div>
    </div>
</div>

<div id="myModal" class="modal"> 
    <div class="modal-content"> 
        <span class="close-modal">&times;</span>
        <div id="modal-main">
            <div id="translation"></div>
            <div id="return_sentence"></div>
        </div>

        <div id="actionButtons">
            <img id="record" src="images/recordingButton.png" alt="record icon"/>
            <img id="robot" src="images/robot_talk_white.png" alt="robot"/>
        </div>
   
        <div id="bottom">
            <select id="language-select"></select>
        </div>
        
        <!-- Add status indicator -->
        <div id="recording-status" style="display: none;">
            <div class="status-spinner"></div>
            <div class="status-message">Processing...</div>
        </div>
    </div>
</div>

<div id="user-modal" class="modal user-modal">
    <div class="modal-content user-modal-content">
        <span class="close">&times;</span>
        <p>User account interaction</p>
        <div id="inputs-account">
            <input type="text" id="user-name" placeholder="Username">
            <input type="password" id="user-password" placeholder="Password">
        </div>
        <div id="buttons-account">
            <button id="login-button">Login</button>
            <button id="signup-button">Sign up</button>
            <button id="forgot-password-button">Forgot password?</button>
        </div>
    </div>
</div>

<div id="user-account-options-modal" class="modal user-account-options-modal">
    <div class="modal-content user-account-options-modal-content">
        <span class="close options-close">&times;</span>
        <p>User account options</p>
        <button id="change-info-button">Change info</button>
        <button id="delete-account-button">Delete account</button>
    </div>
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    fileInput.style.display= "none";
    let currentBook = null;
    let rendition = null;
    let selectedText = null;
    let lines = []; 
    let lineNum = 0;
    let language = "";
    let isRecording = false; 
    let translationText = "";

    let mediaRecorder; 
    let audioChunks = []; //buffer

    const modalDiv = document.getElementById('myModal');
    const closeBtn = document.getElementsByClassName('close')[0];
    
    const selectDiv = document.getElementById('selectedText');
    const prevArrowBtn = document.getElementsByClassName('arrowPrev')[0];
    const nextArrowBtn = document.getElementsByClassName('arrowNext')[0];
    const returnSentenceDiv = document.getElementById('return_sentence');
    const languageSel =document.getElementById('language-select');
    const fileDiv = document.getElementById("file");

    const nextPageBtn = document.getElementById('next');
    const prevPageBtn = document.getElementById('prev');
    const selectBtn = document.getElementById('select');

    const settingsBtn = document.getElementById ("settings");
    const drawer = document.getElementById('settings-drawer');
    const closeDrawerBtn = document.getElementById('close-drawer');
    const availableBooksBtn = document.getElementById('available-books');

    const recordBtn = document.getElementById('record'); 
    const textToSpeechBtn = document.getElementById('robot');
    const translation = document.getElementById('translation');
    
    const languageDisplay2 = document.getElementById('userLanguages');
    const languageUserOptionsSelect = document.getElementById('languageUserOptions');
    
    const abbreviations = [
        'Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Prof.',
        'Sr.', 'Jr.', 'etc.', 'e.g.', 'i.e.', '."'
    ];

    let socket = new WebSocket('wss://carriertech.uk:8675');; // Declare socket variable. Built-in object of js
    const booksModal = document.getElementById('books-modal');

    // First, get reference to your slider
    const speedSlider = document.querySelector('.vertical-slider'); // Adjust selector as needed
    let speechRate = 1; // Default speech rate
    let popupflag=false;
    // Add event listener to the slider
   
    const userAccountBtn = document.getElementById('user-account');
    const usernameInput = document.getElementById('user-name');
    const passwordInput = document.getElementById('user-password');
    const loginButton = document.getElementById ('login-button');
    const signupButton = document.getElementById ('signup-button');
    const forgotPasswordButton = document.getElementById ('forgot-password-button');
    const userAccountOptionsBtn = document.getElementById ('user-account-options');
    const changeInfoButton = document.getElementById ('change-info-button');
    const deleteAccountButton = document.getElementById ('delete-account-button');

    let username = '';
    let password = '';

    const voiceGenderDisplay = document.getElementById('voice-gender');
    const voiceGenderSelect = document.getElementById('voice-gender-select');
    let voiceGenderOptionsOpen = false;
    let availableVoices = [];
    let selectedVoiceGender = 'female'; // Default to female

console.log ("starting script");

// Replace the existing WebSocket implementation with a more structured approach
function createWebSocketConnection() {
    // Singleton instance
    let socketInstance = null;
    let isConnecting = false;
    let messageCallbacks = new Map();
    let connectionQueue = [];
    
    // Create a promise-based WebSocket request function
    async function makeWebSocketRequest(requestData) {
        return new Promise(async (resolve, reject) => {
            try {
                // Generate a unique ID for this request
                const requestId = Date.now().toString() + Math.random().toString(36).substring(2, 15);
                requestData.id = requestId;
                
                // Ensure we have a connection
                const socket = await getSocket();
                
                // Register callback for this specific request
                messageCallbacks.set(requestId, (response) => {
                    resolve(response);
                    messageCallbacks.delete(requestId);
                });
                
                // Send the request
                socket.send(JSON.stringify(requestData));
                
                // Set timeout for request
                setTimeout(() => {
                    if (messageCallbacks.has(requestId)) {
                        messageCallbacks.delete(requestId);
                        reject(new Error("WebSocket request timed out"));
                    }
                }, 30000); // 30 second timeout
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Get or create socket connection
    async function getSocket() {
        // If we already have a working connection, return it
        if (socketInstance && socketInstance.readyState === WebSocket.OPEN) {
            return socketInstance;
        }
        
        // If we're in the process of connecting, wait for it
        if (isConnecting) {
            return new Promise((resolve, reject) => {
                connectionQueue.push({ resolve, reject });
            });
        }
        
        // Start a new connection
        isConnecting = true;
        
        try {
            // Close existing socket if it exists
            if (socketInstance) {
                try {
                    socketInstance.close();
                } catch (e) {
                    console.log("Error closing existing socket:", e);
                }
            }
            
            // Create new connection
            socketInstance = new WebSocket('wss://carriertech.uk:8675');
            
            return new Promise((resolve, reject) => {
                // Set up event handlers
                socketInstance.addEventListener('open', () => {
                    console.log('WebSocket connection established');
                    isConnecting = false;
                    
                    // Resolve this promise
                    resolve(socketInstance);
                    
                    // Resolve any queued promises
                    connectionQueue.forEach(queued => queued.resolve(socketInstance));
                    connectionQueue = [];
                });
                
                socketInstance.addEventListener('close', (event) => {
                    console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);
                    socketInstance = null;
                    
                    // If we're still connecting, this is an error
                    if (isConnecting) {
                        isConnecting = false;
                        reject(new Error(`Failed to connect: ${event.code} ${event.reason}`));
                        
                        // Reject any queued promises
                        connectionQueue.forEach(queued => 
                            queued.reject(new Error(`Connection closed: ${event.code} ${event.reason}`))
                        );
                        connectionQueue = [];
                    }
                });
                
                socketInstance.addEventListener('error', (error) => {
                    console.error('WebSocket error:', error);
                    
                    // If we're still connecting, this is an error
                    if (isConnecting) {
                        isConnecting = false;
                        reject(error);
                        
                        // Reject any queued promises
                        connectionQueue.forEach(queued => queued.reject(error));
                        connectionQueue = [];
                    }
                });
                
                socketInstance.addEventListener('message', (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        console.log("Received WebSocket message:", response);
                        
                        // Hide recording status indicator
                        const statusIndicator = document.getElementById('recording-status');
                        if (statusIndicator) {
                            statusIndicator.style.display = 'none';
                        }
                        
                        // Check if this is a response to a specific request
                        if (response.id && messageCallbacks.has(response.id)) {
                            messageCallbacks.get(response.id)(response);
                            return;
                        }
                        
                        // Handle different types of responses
                        if (response.books) {
                            handleBooksResponse(response);
                        } else if (response.hasOwnProperty('pred_sentence')) {
                            handlePredSentenceResponse(response);
                        } else if (response.hasOwnProperty('translation') || 
                                  (response.status === 'success' && response.hasOwnProperty('translated_text'))) {
                            handleTranslationResponse(response);
                        } else {
                            console.log("Unhandled response from server:", response);
                        }
                    } catch (error) {
                        console.error("Error processing WebSocket message:", error);
                    }
                });
            });
        } catch (error) {
            isConnecting = false;
            throw error;
        }
    }
    
    // Return the public API
    return {
        // Make a WebSocket request and get a response
        request: makeWebSocketRequest,
        
        // Get books from the server
        getBooks: async function() {
            return makeWebSocketRequest({ task: "get_books" });
        },
        
        // Translate text
        translate: async function(text, sourceLang, targetLang) {
            return makeWebSocketRequest({
                task: "translate",
                text: text,
                source_lang: sourceLang,
                target_lang: targetLang
            });
        },
        
        // Speech to text
        speechToText: async function(blob, language, sentence, username, password) {
            return makeWebSocketRequest({
                task: "stt",
                username: username,
                password: password,
                language: language.substring(0,2),
                blob: blob,
                sentence: sentence
            });
        },
        
        // Login
        login: async function(username, password) {
            return makeWebSocketRequest({
                username: username,
                password: password
            });
        },
        
        // Close the connection
        close: function() {
            if (socketInstance && socketInstance.readyState === WebSocket.OPEN) {
                socketInstance.close();
                socketInstance = null;
            }
        }
    };
}

// Create a single instance of the WebSocket connection manager
const wsConnection = createWebSocketConnection();

// Handler functions for different types of responses
function handleBooksResponse(response) {
    // Group books by language
    const booksByLanguage = response.books.reduce((acc, book) => {
        if (!acc[book.language]) {
            acc[book.language] = [];
        }
        acc[book.language].push(book);
        return acc;
    }, {});
    
    // Update language-select options
    const languageSelect = document.getElementById('language-select');
    languageSelect.innerHTML = '';
    
    Object.keys(booksByLanguage).forEach(language => {
        const option = document.createElement('option');
        option.value = language.toLowerCase();
        option.textContent = language.charAt(0).toUpperCase() + language.slice(1);
        languageSelect.appendChild(option);
    });

    // Update books grid
    const booksGrid = document.getElementById('books-grid');
    booksGrid.innerHTML = '';
    
    Object.entries(booksByLanguage).forEach(([language, languageBooks]) => {
        const languageSection = document.createElement('div');
        languageSection.className = 'language-section';
        
        const languageHeader = document.createElement('h2');
        languageHeader.textContent = language.charAt(0).toUpperCase() + language.slice(1);
        languageSection.appendChild(languageHeader);
        
        const booksContainer = document.createElement('div');
        booksContainer.className = 'books-container';
        
        languageBooks.forEach(book => {
            const bookElement = document.createElement('div');
            bookElement.className = 'book';

            const img = document.createElement('img');
            // Check if cover is base64 data or path
            if (book.cover && book.cover.startsWith('data:')) {
                img.src = book.cover;
            } else {
                // Fallback to default cover if the base64 data is invalid
                img.src = 'images/default-cover.png';
                console.error('Invalid cover data for book:', book.filename);
            }
            img.alt = book.filename;
            
            const title = document.createElement('div');
            title.className = 'book-title';
            title.textContent = book.filename.replace('.epub', '');
            
            bookElement.appendChild(img);
            bookElement.appendChild(title);
            
            // Add click event to load the book
            bookElement.addEventListener('click', () => {
              
                    // Create a Blob from the base64 data
                    if (!book.epub) {
                        console.error('No EPUB data received for book:', book.filename);
                        return;
                    }

                    const epubData = book.epub;
                    const base64Data = epubData.split(',')[1];
                    if (!base64Data) {
                        console.error('Invalid EPUB data format for book:', book.filename);
                        return;
                    }

                    const byteString = atob(base64Data);
                    const mimeString = epubData.split(',')[0].split(':')[1].split(';')[0];
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    const blob = new Blob([ab], {type: mimeString});
                    renderEpub(blob);
                    booksModal.style.display = 'none';
                    languageSelect.value = language;
                    
                
            });
            
            booksContainer.appendChild(bookElement);
        });
        
        languageSection.appendChild(booksContainer);
        booksGrid.appendChild(languageSection);
    });
}

function handlePredSentenceResponse(response) {
    returnSentenceDiv.innerHTML = response.pred_sentence;
    
    // Use a proper async function to handle this
    handlePredSentence(response.pred_sentence);
}

function handleTranslationResponse(response) {
    // Handle translation response
    const translatedText = response.translation || response.translated_text;
    translation.innerHTML = translatedText;
    console.log("Updated translation with:", translatedText);
}

// Update functions that use WebSocket to use the new API
async function loadAvailableBooks() {
    try {
        await wsConnection.getBooks();
    } catch (error) {
        console.error("Error loading books:", error);
        alert("Failed to load books. Please try again.");
    }
}

async function updateTranslation(text, sourceLang) {
    console.log(`Translating text: "${text}" from ${sourceLang}`);
    
    // Show loading indicator
    translation.textContent = "Translating...";
    
    // Get user's native language from settings
    const targetLang = languageUserOptionsSelect.value;
    console.log("targetLang: ", targetLang);
 
    try {
        await wsConnection.translate(text, sourceLang, targetLang);
    } catch (error) {
        console.error("Translation error:", error);
        translation.textContent = "Translation failed. Please try again.";
    }
}

async function createBlobAndConnect() {
    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
    
    // Show status indicator with initial message
    const statusIndicator = document.getElementById('recording-status');
    const statusMessage = statusIndicator.querySelector('.status-message');
    statusIndicator.style.display = 'flex';
    statusMessage.textContent = 'Getting audio ready...';
    
    try {
        // Convert blob to base64
        const base64Blob = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(audioBlob);
        });
        
        // Update status message
        statusMessage.textContent = 'Waiting for response...';
        
        // Send to server
        await wsConnection.speechToText(
            base64Blob, 
            languageSel.value.substring(0,2), 
            lines[lineNum],
            username,
            password
        );
        
        // Clear audio chunks for next recording
        audioChunks = [];
        
    } catch (error) {
        console.error("Error processing audio:", error);
        statusMessage.textContent = 'Error processing audio';
        setTimeout(() => {
            statusIndicator.style.display = 'none';
        }, 2000);
    }
}

// Update login button click handler
loginButton.addEventListener('click', async () => {
    loginButton.style.backgroundColor = '#FFB6C1';
    username = usernameInput.value;
    password = passwordInput.value;

    console.log("login button clicked");
    console.log("username is: ", username);
    console.log("password is: ", password);

    try {
        const response = await wsConnection.login(username, password);
        console.log("Login response:", response);
        // Handle login response here
    } catch (error) {
        console.error("Login error:", error);
        alert("Login failed. Please try again.");
    }
});

// Initialize when the page loads
window.addEventListener('DOMContentLoaded', () => {
    initializeVoices();
});

// Update the browse books button event listener
document.getElementById('browse-books-btn').addEventListener('click', () => {
    loadAvailableBooks();
    const booksModal = document.getElementById('books-modal');
    booksModal.style.display = 'block';
});

function loadAvailableBooks() {
    wsConnection.getBooks().catch(error => {
        console.error("Error loading books:", error);
    });
}

// Add this to your existing WebSocket message handler
socket.addEventListener('message', (event) => {
    const msg = JSON.parse(event.data);
    
    // Hide recording status indicator whenever we receive any message
    const statusIndicator = document.getElementById('recording-status');
    if (statusIndicator) {
        statusIndicator.style.display = 'none';
    }
    
    if (msg.books) {
        // Group books by language
        const booksByLanguage = msg.books.reduce((acc, book) => {
            if (!acc[book.language]) {
                acc[book.language] = [];
            }
            acc[book.language].push(book);
            return acc;
        }, {});
        
        // Update language-select options
        const languageSelect = document.getElementById('language-select');
        languageSelect.innerHTML = '';
        
        Object.keys(booksByLanguage).forEach(language => {
            const option = document.createElement('option');
            option.value = language.toLowerCase();
            option.textContent = language.charAt(0).toUpperCase() + language.slice(1);
            languageSelect.appendChild(option);
        });

        // Update books grid
        const booksGrid = document.getElementById('books-grid');
        booksGrid.innerHTML = '';
        
        Object.entries(booksByLanguage).forEach(([language, languageBooks]) => {
            const languageSection = document.createElement('div');
            languageSection.className = 'language-section';
            
            const languageHeader = document.createElement('h2');
            languageHeader.textContent = language.charAt(0).toUpperCase() + language.slice(1);
            languageSection.appendChild(languageHeader);
            
            const booksContainer = document.createElement('div');
            booksContainer.className = 'books-container';
            
            languageBooks.forEach(book => {
                const bookElement = document.createElement('div');
                bookElement.className = 'book';

                const img = document.createElement('img');
                // Check if cover is base64 data or path
                if (book.cover && book.cover.startsWith('data:')) {
                    img.src = book.cover;
                } else {
                    // Fallback to default cover if the base64 data is invalid
                    img.src = 'images/default-cover.png';
                    console.error('Invalid cover data for book:', book.filename);
                }
                img.alt = book.filename;
                
                const title = document.createElement('div');
                title.className = 'book-title';
                title.textContent = book.filename.replace('.epub', '');
                
                bookElement.appendChild(img);
                bookElement.appendChild(title);
                
                // Add click event to load the book
                bookElement.addEventListener('click', () => {
                    try {
                        // Create a Blob from the base64 data
                        if (!book.epub) {
                            console.error('No EPUB data received for book:', book.filename);
                            return;
                        }

                        const epubData = book.epub;
                        const base64Data = epubData.split(',')[1];
                        if (!base64Data) {
                            console.error('Invalid EPUB data format for book:', book.filename);
                            return;
                        }

                        const byteString = atob(base64Data);
                        const mimeString = epubData.split(',')[0].split(':')[1].split(';')[0];
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        
                        const blob = new Blob([ab], {type: mimeString});
                        renderEpub(blob);
                        booksModal.style.display = 'none';
                        languageSelect.value = language;
                        
                    } catch (error) {
                        console.error('Error loading book:', error);
                        alert('Error loading book. Please try again.');
                    }
                });
                
                booksContainer.appendChild(bookElement);
            });
            
            languageSection.appendChild(booksContainer);
            booksGrid.appendChild(languageSection);
        });
    } else if (msg.hasOwnProperty('pred_sentence')) {
        returnSentenceDiv.innerHTML = msg.pred_sentence;
        
        // Fix: Use a proper async function to handle this
        handlePredSentence(msg.pred_sentence);
    } else if (msg.hasOwnProperty('translation') || 
              (msg.status === 'success' && msg.hasOwnProperty('translated_text'))) {
        // Handle translation response
        const translatedText = msg.translation || msg.translated_text;
        translation.innerHTML = translatedText;
        console.log("Updated translation with:", translatedText);
    } else {
        console.log("got some reply from server ", msg);
    }
});

// Add this new function to handle the prediction sentence
async function handlePredSentence(predSentence) {
    returnSentenceDiv.innerHTML = predSentence;
    
    // Wait for the DOM to update
    await new Promise(resolve => requestAnimationFrame(resolve));

    // Now query for elements with class "wrong"
    const wrongElements = document.getElementsByClassName("wrong");
    console.log("OLIVIA'S TRIAL: wrongElements: ", wrongElements);
    
    // Now you can work with the wrong elements
    for (const element of wrongElements) {
        // Your code for handling wrong elements
        element.addEventListener('click', (event) => {
            createPopup(element.id, event);
        });
    }
}

// Call loadAvailableBooks when the available books button is clicked
availableBooksBtn.addEventListener('click', () => {
    loadAvailableBooks();
    const booksModal = document.getElementById('books-modal');
    booksModal.style.display = 'block';
});

// Close books modal
document.querySelectorAll('.modal .close').forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        closeBtn.closest('.modal').style.display = 'none';
    });
});
    // Separate function for epub rendering
    function renderEpub(file) {
        currentBook = ePub(file);
        viewer.innerHTML = "";
        rendition = currentBook.renderTo("viewer", {
            height: "100%",
            width: "100%",
            allowScriptedContent: true,
            script: true,
            spread: "none",
            flow: "paginated",
            manager: "default"
        });
        
        rendition.display().then(() => {            
            const contents = rendition.getContents();
            
            rendition.on("rendered", (section, view) => {
                const contents = rendition.getContents();
                
                contents.forEach(content => {
                    // Add click handlers to paragraphs and spans
                    content.document.querySelectorAll('p, span').forEach(element => {
                        // Check if element has at least 2 words
                        const words = element.textContent.trim().split(/\s+/);
                        if (words.length < 2) return; // Skip elements with fewer than 2 words
                        
                        // Create and add the select icon
                        const selectIcon = content.document.createElement('div');
                        selectIcon.innerHTML = `
                            <svg width="16" height="16" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="10" fill="#4588a0" fill-opacity="0.7"/>
                                <path d="M7 12h10" stroke="white" stroke-width="2"/>
                                <path d="M12 7v10" stroke="white" stroke-width="2"/>
                            </svg>`;
                        selectIcon.style.position = 'absolute';
                        selectIcon.style.left = '-3em';
                        selectIcon.style.top = '50%';
                        selectIcon.style.transform = 'translateY(-50%)';
                        
                        // Make the parent element relative for absolute positioning
                        element.style.position = 'relative';
                        element.style.paddingLeft = '8px';
                        element.style.marginLeft = '24px';
                        
                        // Insert the icon
                        element.insertBefore(selectIcon, element.firstChild);
                        
                        // Rest of the styles
                        element.style.cursor = 'pointer';
                        element.style.borderRadius = '3px';
                        element.style.transition = 'background-color 0.2s ease';
                        element.style.display = 'block';
                        
                        // Add hover effect
                        element.addEventListener('mouseover', () => {
                            element.style.backgroundColor = 'rgba(169, 209, 215, 0.3)';
                            selectIcon.querySelector('circle').setAttribute('fill-opacity', '1');
                        });
                        
                        element.addEventListener('mouseout', () => {
                            if (!element.classList.contains('selected-line')) {
                                element.style.backgroundColor = 'transparent';
                                selectIcon.querySelector('circle').setAttribute('fill-opacity', '0.7');
                            }
                        });
                        
                        // Add click handler
                        element.addEventListener('click', (event) => {
                            // Remove previous selection
                            content.document.querySelectorAll('.selected-line').forEach(el => {
                                el.classList.remove('selected-line');
                                el.style.backgroundColor = 'transparent';
                                el.querySelector('circle')?.setAttribute('fill-opacity', '0.7');
                            });
                            
                            // Add selection to clicked element
                            element.classList.add('selected-line');
                            element.style.backgroundColor = 'rgba(169, 209, 215, 0.5)';
                            selectIcon.querySelector('circle').setAttribute('fill-opacity', '1');
                            
                            // Get the text and show alert
                            selectedText = element.textContent.trim();
                            lines = [selectedText];
                            lineNum = 0;
                            
                            // Position and show modal
                            const elementRect = element.getBoundingClientRect();
                            const viewerRect = document.getElementById('viewer').getBoundingClientRect();
                            const modal = document.getElementById('myModal');
                            
                            if (modal) {
                                // IMPROVED MODAL POSITIONING FOR MOBILE
                                const isMobile = window.innerWidth <= 768;
                                const modalContent = modal.querySelector('.modal-content');
                                
                                // Calculate the position of the element relative to the viewer
                                const relativeTop = elementRect.top - content.window.pageYOffset;
                                const relativeBottom = elementRect.bottom - content.window.pageYOffset;
                                const elementCenter = elementRect.top + (elementRect.height / 2);
                                
                                // Calculate the absolute position in the parent document
                                let absoluteTop;
                                
                                // Get modal height (if already visible) or estimate it
                                const modalHeight = modal.offsetHeight || 300; // Use 300px as fallback estimate
                                
                                if (isMobile) {
                                    // On mobile, center the modal over the element
                                    absoluteTop = viewerRect.top + relativeTop - (modalHeight / 4);
                                    
                                    // Ensure modal stays within viewport
                                    const maxTop = window.innerHeight - modalHeight - 20;
                                    const minTop = 20; // Minimum 20px from top
                                    absoluteTop = Math.max(minTop, Math.min(absoluteTop, maxTop));
                                    
                                    // Use full width on mobile with small margins
                                    modalContent.style.width = `calc(100vw - 20px)`;
                                    modalContent.style.maxWidth = '100%';
                                    modal.style.left = '10px';
                                } else {
                                    // On desktop, position below or above the element
                                    absoluteTop = viewerRect.top + relativeBottom + 20; // 20px gap below element
                                    
                                    // Check if modal would go off screen at the bottom
                                    if (absoluteTop + modalHeight > window.innerHeight) {
                                        // Place above the element instead
                                        absoluteTop = viewerRect.top + relativeTop - modalHeight - 20; // 20px gap above element
                                    }
                                    
                                    // Use the viewer's x position
                                    const modalLeft = viewerRect.left + 20; // 20px margin from left of viewer
                                    modal.style.left = `${modalLeft}px`;
                                    
                                    // Set width based on viewer
                                    const modalWidth = viewerRect.width - 40; // 20px margin on each side
                                    modalContent.style.width = `${modalWidth}px`;
                                }
                                
                                // Position modal
                                modal.style.position = 'fixed';
                                if (absoluteTop < 0) {
                                    absoluteTop = 0;
                                }
                                modal.style.top = `${absoluteTop}px`;
                                
                                modal.style.display = "block";
                                console.log("Modal positioned at:", {
                                    left: isMobile ? '10px' : modal.style.left, 
                                    top: absoluteTop, 
                                    width: modalContent.style.width,
                                    height: modalHeight,
                                    isMobile: isMobile,
                                    elementCenter: elementCenter,
                                    viewerTop: viewerRect.top
                                });
                            } else {
                                console.error("Modal element not found");
                            }
                            
                            // Update translation
                            const translationDiv = document.getElementById('translation');
                            if (translationDiv) {
                               updateTranslation(selectedText, languageSel.value);
                            }
                            
                            // Prevent the click from propagating to the window
                            event.stopPropagation();
                        });
                    });
                });
            });
        });

        // Hide the navigation div since we're using side buttons
        fileDiv.style.display = "none";
    }

    recordBtn.addEventListener('click', async () => { //standarised procedure 
        if (!isRecording) {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); //built-in function of mozilla to get the media of the user
            mediaRecorder = new MediaRecorder(stream); //object pre-built
            
            mediaRecorder.ondataavailable = event => { //event = the object has changed in some way. every ms that you talk and it gets saved in the array
                audioChunks.push(event.data);  //saving the audio into an array
            };

            mediaRecorder.start();
            recordBtn.src = "images/stopRecButton.png";
            //socket.send(JSON.stringify({ event: 'start' })); // Notify server that recording has started
            isRecording=true;

         } else {   //this means that isRecording==true;
            mediaRecorder.stop(); 
            isRecording=false;
            recordBtn.src = "images/recordingButton.png";
         }        
        mediaRecorder.onstop = () => {
            createBlobAndConnect(); // Call the function to create the blob and connect
            //socket.send(JSON.stringify({ event: 'stop' })); // Notify server that recording has stopped
        };

       
    });

    const closeModalBtn = document.querySelector('.close-modal');

    // Add event listener for the new close button
    closeModalBtn.addEventListener('click', () => {
        modalDiv.style.display = "none";
        lineNum = 0;
    });

    // Close modal when clicking outside
    window.addEventListener('click',(event)=> {
        if (event.target==modalDiv) {
            modalDiv.style.display = "none";
        }
    });

    fileInput.addEventListener('change', async (event) => { //change=file selected
        const file = event.target.files[0]; //the element that triggered the event (the file input)
        if (file) {
            renderEpub(file);
        }
    });

    fileDiv.addEventListener('click',()=> {
        fileInput.click();
    })

    settingsBtn.addEventListener('click',()=> {
        console.log("settings button clicked");
        drawer.classList.add('open'); //adding a class named 'open'
    });

    closeDrawerBtn.addEventListener('click', () => {
        drawer.classList.remove('open'); //removing a class named 'open'
    });

    window.addEventListener('click', (event) => {
        if (!drawer.contains(event.target) && event.target !== settingsBtn) {
            drawer.classList.remove('open');
        }
    });

    nextPageBtn.addEventListener('click', () => {
        console.log("nextPageBtn clicked");
        if (rendition) { //if an epub is loaded
            rendition.next().then(extractVisibleText); //next is a method from epub.js to go to the next page
        }
    })

    prevPageBtn.addEventListener('click',() =>{
        console.log("prevPageBtn clicked");
        if (rendition){
            rendition.prev().then(extractVisibleText);
        }
    } )

    textToSpeechBtn.addEventListener('click', () => {
        if ('speechSynthesis' in window) {
            textToSpeech(lines[lineNum]);
        } else {
            console.log("Sorry, your browser doesn't support text to speech!");
        }
    })
    
    
    function randomLanguage(){
        const languages = ['en', 'es', 'fr', 'de', 'it'];
        return languages[Math.floor(Math.random() * languages.length)];
    }

    function textToSpeech(textToSpeak) {
        if ('speechSynthesis' in window) {
            console.log('Starting text-to-speech for:', textToSpeak);
            
            let msg = new SpeechSynthesisUtterance();
            msg.text = textToSpeak;
            
            // Make sure we're using the correct language
            const currentLang = languageSel.value.substring(0,2);
            console.log('Using language:', currentLang);
            msg.lang = currentLang;
            
            // Match the settings from the robot button
            msg.rate = 1;
            msg.volume = 1;
            msg.pitch = 1;
            
            // Select a voice based on gender preference
            const voices = window.speechSynthesis.getVoices();
            
            // Filter voices by language and gender
            const matchingVoices = voices.filter(voice => {
                // Check if voice language matches or contains our target language
                const voiceLang = voice.lang.toLowerCase();
                const targetLang = currentLang.toLowerCase();
                const langMatch = voiceLang.startsWith(targetLang) || voiceLang.includes(targetLang);
                
                // Determine gender based on voice name (common pattern in voice APIs)
                // This is a heuristic and may not be 100% accurate
                const isFemaleName = voice.name.toLowerCase().includes('female') || 
                                   voice.name.toLowerCase().includes('woman') ||
                                   voice.name.toLowerCase().includes('girl') ||
                                   voice.name.toLowerCase().includes('fiona') ||
                                   voice.name.toLowerCase().includes('samantha') ||
                                   voice.name.toLowerCase().includes('victoria');
                                   
                const isMaleName = voice.name.toLowerCase().includes('male') || 
                                 voice.name.toLowerCase().includes('man') ||
                                 voice.name.toLowerCase().includes('guy') ||
                                 voice.name.toLowerCase().includes('david') ||
                                 voice.name.toLowerCase().includes('thomas') ||
                                 voice.name.toLowerCase().includes('daniel');
                
                // Match based on selected gender
                const genderMatch = (selectedVoiceGender === 'female' && isFemaleName) || 
                                  (selectedVoiceGender === 'male' && isMaleName);
                
                return langMatch && genderMatch;
            });
            
            console.log(`Found ${matchingVoices.length} matching voices for ${currentLang} and gender ${selectedVoiceGender}`);
            
            // Use the first matching voice, or fall back to default
            if (matchingVoices.length > 0) {
                msg.voice = matchingVoices[0];
                console.log("Selected voice:", msg.voice.name);
            } else {
                console.log("No matching voice found, using default");
            }
            
            // Add event listeners to debug TTS issues
            msg.onstart = () => console.log('Speech started');
            msg.onend = () => console.log('Speech ended');
            msg.onerror = (e) => console.error('Speech error:', e);
            
            window.speechSynthesis.speak(msg);
        } else {
            console.error("Speech synthesis not supported in this browser");
        }
    }
    
    function createPopup(content, event) {
        // Remove any existing popups first
        document.querySelectorAll('.popup').forEach(popup => popup.remove());
        
        const popup = document.createElement('div');
        const closePopupButton = document.createElement('span');
        const contentElement = document.createElement('p');
        
        // Style the close button
        closePopupButton.innerHTML = '&times;';
        closePopupButton.style.position = 'absolute';
        closePopupButton.style.top = '5px';
        closePopupButton.style.right = '10px';
        closePopupButton.style.cursor = 'pointer';
        closePopupButton.style.fontSize = '18px';
        closePopupButton.style.fontWeight = 'bold';
        closePopupButton.classList.add('popup-close');
        
        contentElement.textContent = content;
        
        popup.appendChild(contentElement);
        popup.appendChild(closePopupButton);
        
        closePopupButton.addEventListener('click', (e) => {
            popup.remove();
            popupflag = false;
            e.stopPropagation();
        });
        
        // Get click/touch position
        const x = event.clientX || (event.touches && event.touches[0].clientX) || 0;
        const y = event.clientY || (event.touches && event.touches[0].clientY) || 0;
        
        popup.style.position = 'absolute'; 
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`; 
        popup.classList.add('popup');
        
        document.body.appendChild(popup);
        popup.style.zIndex = 1000;
        
        // Fix: Call textToSpeech with the correct language
        if (content) {
            console.log("Speaking content:", content);
            // Use the current language from languageSel
            textToSpeech(content);
        } else {
            console.error("No content to speak");
        }
        
        popupflag = true;
    }
    
    // Add a global click event listener to document
    document.addEventListener('click', (event) => {
        const popups = document.querySelectorAll('.popup');
        if (popups.length > 0) {
            // Check if the click was inside a popup or on a wrong element
            const clickedInsidePopup = Array.from(popups).some(popup => popup.contains(event.target));
            const clickedOnWrongElement = event.target.classList.contains('wrong');
            const clickedOnPopupClose = event.target.classList.contains('popup-close');
            
            // If clicked outside popup and not on a wrong element, remove all popups
            if (!clickedInsidePopup && !clickedOnWrongElement && !clickedOnPopupClose) {
                popups.forEach(popup => popup.remove());
                popupflag = false;
            }
        }
    });

    function openUserAccount() {
        document.getElementById('user-modal').style.display = 'block';
       }

    signupButton.addEventListener('click', () => {
        signupButton.style.backgroundColor = '#FFB6C1';
        username=usernameInput.value;
        password=passwordInput.value;
        console.log("signup button clicked");
        console.log("username is: ", username);
        console.log("password is: ", password);

    });

    function openUserAccountOptions() {
        document.getElementById('user-account-options-modal').style.display = 'block';
    }

    function initializeVoices() {
        // Get the available voices
        availableVoices = window.speechSynthesis.getVoices();
        
        // If voices aren't loaded yet, wait for them
        if (availableVoices.length === 0) {
            window.speechSynthesis.addEventListener('voiceschanged', () => {
                availableVoices = window.speechSynthesis.getVoices();
                console.log("Available voices:", availableVoices);
            }, { once: true }); // Add the 'once' option to only trigger this once
        } else {
            console.log("Available voices:", availableVoices);
        }
    }

    // Add event listener for voice gender selection
    voiceGenderDisplay.addEventListener('click', () => {
        if (voiceGenderOptionsOpen) {
            voiceGenderOptionsOpen = false;
            voiceGenderSelect.style.transform = 'translateX(1000%)';
        } else {
            voiceGenderSelect.style.transform = 'translateX(0)';
            voiceGenderOptionsOpen = true;
        }
    });

    // Update selected voice gender when changed
    voiceGenderSelect.addEventListener('change', () => {
        selectedVoiceGender = voiceGenderSelect.value;
        console.log("Selected voice gender:", selectedVoiceGender);
    });

    // Add event listener for text selection in the viewer
    const viewerElement = document.getElementById('viewer');
    if (viewerElement) {
        viewerElement.addEventListener('mouseup', handleTextSelection);
        viewerElement.addEventListener('touchend', handleTextSelection);
    }
    
    // Make sure language selection changes trigger retranslation
    languageSel.addEventListener('change', function() {
        if (translationText) {
            updateTranslation(translationText, this.value);
        }
    });

    // Update the handleTextSelection function to properly use updateTranslation
    function handleTextSelection() {
        const selection = window.getSelection();
        const text = selection.toString().trim();
        
        if (text && text.length > 0) {
            console.log("Selected text:", text);
            selectedText = text;
            
            // Show the modal with the selected text
            modalDiv.style.display = "block";
            
            // Get the target language from the language select dropdown
            const targetLang = languageSel.value;
            
            // Store the selected text for later use
            translationText = text;
            
            // Trigger translation immediately
            updateTranslation(text, targetLang);
        }
    }

    // Fix the extractVisibleText function to handle errors better
    function extractVisibleText() {
        console.log("extractVisibleText called");
        const location = rendition.currentLocation();
        console.log("Current location:", location);

        const makeRangeCfi = (a, b) => {
                const CFI = new ePub.CFI()
                const start = CFI.parse(a), end = CFI.parse(b)
                const cfi = {
                    range: true,
                    base: start.base,
                    path: {
                        steps: [],
                        terminal: null
                    },
                    start: start.path,
                    end: end.path
                }
                const len = cfi.start.steps.length
                for (let i = 0; i < len; i++) {
                    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
                        if (i == len - 1) {
                            if (cfi.start.terminal === cfi.end.terminal) {
                                cfi.path.steps.push(cfi.start.steps[i])
                                cfi.range = false
                            }
                        } else cfi.path.steps.push(cfi.start.steps[i])
                    } else break
                }
                cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)
                cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)

                return 'epubcfi(' + CFI.segmentString(cfi.base)
                    + '!' + CFI.segmentString(cfi.path)
                    + ',' + CFI.segmentString(cfi.start)
                    + ',' + CFI.segmentString(cfi.end)
                    + ')'
            }

        if (location && location.start && location.end) {
            const rangeCfi = makeRangeCfi(location.start.cfi, location.end.cfi);
            console.log("Range CFI created:", rangeCfi);
            
            currentBook.getRange(rangeCfi)
                .then(range => {
                    if (range) {
                        selectedText = range.toString();
                        console.log("Raw selected text:", selectedText);
                        
                        // Clean up text
                        selectedText = cleanText(selectedText);
                        console.log("Cleaned selected text:", selectedText);
                        
                        lines = selectedText.split('.')
                            .map(line => line.trim())
                            .filter(line => line.length > 0)
                            .map(line => line + '.');
                        
                        console.log("Lines array:", lines);
                        console.log("Number of lines:", lines.length);
                    } else {
                        console.log("Range is null or undefined");
                    }
                })
                .catch(error => {
                    console.error('Error getting range:', error);
                    // Initialize empty lines array to prevent further errors
                    lines = [];
                });
        } else {
            console.log("Location is invalid:", location);
        }
    }
    
    // Separate text cleaning function
    function cleanText(text) {
        const regexMatch = /[A-Z]\./g;
        text = text.replace(regexMatch, match => match.replace('.', ''));
        
        abbreviations.forEach(abbr => {
            let clean = abbr.replaceAll(".", "");
            text = text.replaceAll(abbr, clean);
        });
        
        return text;
    }

</script>
