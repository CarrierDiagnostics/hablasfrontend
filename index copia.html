<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto:wght@400;700&family=Quicksand:wght@400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet"> <!-- Include Lato, Roboto, and Montserrat fonts -->
<link rel="stylesheet" href="style.css">
<body>
    
    <div id="title">
        <p>Hablas</p>
        <img src="images/settings.png" id="settings"/> 
    </div>

    <div id="div2viewer">
            <div id="viewer">
                <div id="empty-viewer-message">
                    <p>No book loaded</p>
                    <button id="browse-books-btn" onclick="loadAvailableBooks()">Browse Available Books</button>
                </div>
            </div> 
    </div>

    <input type="file" id="fileInput" accept=".epub"/>
     
    <div id="settings-drawer" class="drawer">
            <span id="close-drawer" class="close">&times;</span>
            <h2>Settings</h2>
            <div id="settings-options">
                <input type="text" id="user-name" placeholder="Email">
                <input type="password" id="user-password" placeholder="Password">
                <div id="login-singup" style="display: flex; width: 100%; gap: 10px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">
                    <div id="login-button" class="options" style="flex: 1;">Login</div>
                    <div id="signup-button" class="options" style="flex: 1;">Sign up</div>
                 </div>
                <div id="available-books" class="options">Available books</div>
                <div id="userLanguages"  class="options">Native Language</div>
                <select id="languageUserOptions" default="en" class="settings-select">
                    <option value="en">English</option>
                    <option value="es">Spanish</option> 
                    <option value="fr">Français</option>
                    <option value="de">Deutch</option>
                    <option value="it">Italian</option>
                </select>
                <div id="voice-gender" class="options">Voice Gender</div>
                <select id="voice-gender-select" class="settings-select">
                    <option value="female">Female</option>
                    <option value="male">Male</option>
                </select>
                <div id="points-display">Points: <span id="points">0</span></div>
                <div id="file">
                    <img src="images/upload-icon-white.png" alt="upload symbol" />
                    <img src="images/epub-icon-white.png" alt="upload symbol" />
                </div>
                <div id="feedback-button" class="options">Feedback</div>
            </div>
    </div>


<div id="books-modal" >
    <div class="modal-content">
        <span class="close">&times;</span>
        <div id="books-grid"></div>
    </div>
</div>

<div id="myModal" class="modal"> 
    <div class="modal-content" id="modal-content"> 
        <span class="close-modal">&times;</span>
        <div id="modal-main">
            <div id="translation"></div>
            <div id="return_sentence">>></div>
        </div>

        <div id="actionButtons" style="position: relative;">
            <img id="record" src="images/recordingButton.png" alt="record icon"/>
            <img id="robot" src="images/robot_talk_white.png" alt="robot" data-speaking="false"/>
            <div id="points-display">Points: <span id="points">0</span></div>
            
            <div id="recording-status" style="
                display: none;
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;">
                <div class="status-spinner"></div>
                <div class="status-message">Processing...</div>
                <div class="timer">0.0s</div>
            </div>
        </div>
   
        <!-- Add status indicator -->
        <div id="recording-status" style="display: none;">
            <div class="status-spinner"></div>
            <div class="status-message">Processing...</div>
        </div>
    </div>
</div>


<div id="user-account-options-modal" class="modal user-account-options-modal">
    <div class="modal-content user-account-options-modal-content">
        <span class="close options-close">&times;</span>
        <p>User account options</p>
        <button id="change-info-button">Change info</button>
        <button id="delete-account-button">Delete account</button>
    </div>
</div>

<div id="feedback-modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <p>Feedback modal</p>
        <div id="send-feedback-button" class="options">Send feedback!</div>
    </div>
       
    
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    fileInput.style.display= "none";
    let currentBook = null;
    let rendition = null;
    let selectedText = null;
    let lines = []; 
    let lineNum = 0;
    let language = "";
    let isRecording = false; 
    let translationText = "";
    let mediaRecorder; 
    let audioChunks = []; //buffer
    let userPoints = 0;
    const lang_conversion = {
        "francais": "fr",
        "english": "en",
        "español": "es",
        "espagnol": "es",
        "spanish": "es",
        "deutsch": "de",
        "italiano": "it"
    }
    const modalDiv = document.getElementById('myModal');
    const closeBtn = document.getElementsByClassName('close')[0];
    
    const selectDiv = document.getElementById('selectedText');
    const prevArrowBtn = document.getElementsByClassName('arrowPrev')[0];
    const nextArrowBtn = document.getElementsByClassName('arrowNext')[0];
    const returnSentenceDiv = document.getElementById('return_sentence');
    const fileDiv = document.getElementById("file");
    const pointsDisplay = document.getElementById("points-display");

    const nextPageBtn = document.getElementById('next');
    const prevPageBtn = document.getElementById('prev');
    const selectBtn = document.getElementById('select');

    const settingsBtn = document.getElementById ("settings");
    const drawer = document.getElementById('settings-drawer');
    const closeDrawerBtn = document.getElementById('close-drawer');
    const availableBooksBtn = document.getElementById('available-books');

    const recordBtn = document.getElementById('record'); 
    const textToSpeechBtn = document.getElementById('robot');
    const translation = document.getElementById('translation');
    
    const languageDisplay2 = document.getElementById('userLanguages');
    const languageUserOptionsSelect = document.getElementById('languageUserOptions');
    
    const abbreviations = [
        'Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Prof.',
        'Sr.', 'Jr.', 'etc.', 'e.g.', 'i.e.', '."'
    ];

    const booksModal = document.getElementById('books-modal');

    // First, get reference to your slider
    const speedSlider = document.querySelector('.vertical-slider'); // Adjust selector as needed
    let speechRate = 1; // Default speech rate
    let popupflag=false;
    // Add event listener to the slider
   
    const userAccountBtn = document.getElementById('user-account');
    const usernameInput = document.getElementById('user-name');
    const passwordInput = document.getElementById('user-password');
    const loginButton = document.getElementById ('login-button');
    const signupButton = document.getElementById ('signup-button');
    const forgotPasswordButton = document.getElementById ('forgot-password-button');
    const userAccountOptionsBtn = document.getElementById ('user-account-options');
    const changeInfoButton = document.getElementById ('change-info-button');
    const deleteAccountButton = document.getElementById ('delete-account-button');

    let username = '';
    let password = '';

    const voiceGenderDisplay = document.getElementById('voice-gender');
    const voiceGenderSelect = document.getElementById('voice-gender-select');
    const feedbackBtn = document.getElementById('feedback-button');
    const feedbackModal = document.getElementById('feedback-modal');
    const sendFeedbackBtn = document.getElementById('send-feedback-button');
    let voiceGenderOptionsOpen = false;
    let availableVoices = [];
    let selectedVoiceGender = 'female'; // Default to female
    let selectedBook = null;
    let selectedPage = null;
    let sourceLang = "";
    let languageSel ="en";

    // Add these variables at the start of your script
    let processingStartTime = 0;
    let timerInterval = null;

console.log ("starting script");

// Add this function at the start of your script
function waitForEpub() {
    return new Promise((resolve, reject) => {
        if (typeof ePub !== 'undefined') {
            resolve();
        } else {
            // Check every 100ms for up to 5 seconds
            let attempts = 0;
            const interval = setInterval(() => {
                if (typeof ePub !== 'undefined') {
                    clearInterval(interval);
                    resolve();
                } else if (attempts >= 50) { // 5 seconds (50 * 100ms)
                    clearInterval(interval);
                    reject(new Error('ePub library failed to load'));
                }
                attempts++;
            }, 100);
        }
    });
}

// Replace the existing WebSocket implementation with a simpler function-based approach
function createWebSocketConnection() {
    const socket = new WebSocket('wss://carriertech.uk:8675');
    
    socket.addEventListener('open', (event) => {
        console.log('WebSocket connection established');
    });

    socket.addEventListener('error', (error) => {
        console.error('WebSocket error:', error);
    });

    socket.addEventListener('message', (event) => {
            const response = JSON.parse(event.data);
            console.log("Received WebSocket message:", response);
            
            const statusIndicator = document.getElementById('recording-status');
            if (statusIndicator) {
                // Stop and clear the timer
                clearInterval(timerInterval);
                const finalTime = ((Date.now() - processingStartTime) / 1000).toFixed(1);
                const timerElement = statusIndicator.querySelector('.timer');
                if (timerElement) {
                    timerElement.textContent = `${finalTime}s`;
                }
                // Hide the status indicator without a timeout
                statusIndicator.style.display = 'none';
            }
            
            if (response.books) {
                handleBooksResponse(response);
            } else if (response.hasOwnProperty('pred_sentence')) {
                handlePredSentence(response);
            } else if (response.hasOwnProperty('translation') || 
                        (response.status === 'success' && response.hasOwnProperty('translated_text'))) {
                handleTranslationResponse(response);
            } else if (response.hasOwnProperty('token')) {
                handleTokenResponse(response);
            } else if (response.status === 'success' && response.hasOwnProperty('epub')) {
                // Handle book data response
                handleBookDataResponse(response);
            } else if (response.message === "Invalid credentials") {
                alert("Invalid credentials, have you signed up?");
            } else if(response.hasOwnProperty('filename')) {
                    const epubData = response.epub;
                    const base64Data = epubData.split(',')[1];
                    if (!base64Data) {
                        throw new Error('Invalid EPUB data format');
                    }
                    
                    const byteString = atob(base64Data);
                    const mimeString = epubData.split(',')[0].split(':')[1].split(';')[0];
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    const blob = new Blob([ab], {type: mimeString});
                    renderEpub(blob);
                    booksModal.style.display = 'none';
                    
                    languageSel = setLanguage(langauge);
                    selectedBook = book.filename;
                    console.log("selected ", selectedBook);
            }else {
                console.log("Unhandled response from server:", response);
            }
       
    });

    socket.addEventListener('close', (event) => {
        console.log('WebSocket connection closed', event.code, event.reason);
    });
    
    return socket;
}

// Initialize the socket
let socket = createWebSocketConnection();

// Function to send a message through the socket, creating a new connection if needed
function sendSocketMessage(message) {
    if (socket.readyState !== WebSocket.OPEN) {
        console.log('Socket not open, creating new connection');
        socket = createWebSocketConnection();
        
        // Wait for the socket to open before sending the message
        socket.addEventListener('open', () => {
            socket.send(JSON.stringify(message));
        }, { once: true });
    } else {
        socket.send(JSON.stringify(message));
    }
}

// Update functions to use the sendSocketMessage function
function loadAvailableBooks() {
    sendSocketMessage({ task: 'get_books' });
    booksModal.style.display = 'block';
}



function createBlobAndConnect() {
    const statusIndicator = document.getElementById('recording-status');
    if (statusIndicator) {
        statusIndicator.style.display = 'flex';
        // Start the timer
        processingStartTime = Date.now();
        updateTimer();
        timerInterval = setInterval(updateTimer, 100); // Update every 0.1 seconds
    }

    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
    audioChunks = []; // Clear the chunks array for next recording

    // Convert blob to base64
    const reader = new FileReader();
    reader.readAsDataURL(audioBlob);
    reader.onloadend = function() {
        const base64data = reader.result;

        sendSocketMessage({ 
            task: 'stt', 
            audio: base64data, 
            language: languageSel, 
            sentence: lines[lineNum], 
            username: username, 
            book: selectedBook, 
            page: selectedPage 
        });
    };
}

// Update login button click handler
loginButton.addEventListener('click', () => {
    loginButton.style.backgroundColor = '#FFB6C1';
    username = usernameInput.value;
    password = passwordInput.value;

    if (!isValidEmail(username)) {
        alert("Please enter a valid email address");
        return; 
    }

    if (!password || password.trim() === "") {
        alert("Password cannot be empty");
        return; 
    }

    sendSocketMessage({
        task: "login",
        username: username,
        password: password
    });
});

// Update signup button click handler
signupButton.addEventListener('click', () => {
    signupButton.style.backgroundColor = '#FFB6C1';
    username = usernameInput.value;
    password = passwordInput.value;

    if (!isValidEmail(username)) {
        alert("Please enter a valid email address");
        return;
    }

    if (!password || password.trim() === "") {
        alert("Password cannot be empty");
        return;
    }

    sendSocketMessage({
        task: "signup",
        username: username,
        password: password
    });
});

function verifyToken(token) {
    sendSocketMessage({
        task: "verify_token",
        token: token
    });
}

function handleLogout() {
    // Clear stored token
    localStorage.removeItem('token');
    localStorage.removeItem('username');
    
    // Update UI
    updateAuthUI(false);
    
    // Reset any user-specific state
    username = '';
    password = '';
    
    // Close the settings drawer
    drawer.classList.remove('open');
    
    // Notify server about logout
    sendSocketMessage({
        task: "logout",
        username: username
    });
}

// Handler functions for different types of responses
function handleBooksResponse(response) {
    // Group books by language
    const booksByLanguage = response.books.reduce((acc, book) => {
        if (!acc[book.language]) {
            acc[book.language] = [];
        }
        acc[book.language].push(book);
        return acc;
    }, {});
    
   
    const booksGrid = document.getElementById('books-grid');
    booksGrid.innerHTML = '';
    
    Object.entries(booksByLanguage).forEach(([language, languageBooks]) => {
        const languageSection = document.createElement('div');
        languageSection.className = 'language-section';
        
        const languageHeader = document.createElement('h2');
        languageHeader.textContent = language.charAt(0).toUpperCase() + language.slice(1);
        languageSection.appendChild(languageHeader);
        
        const booksContainer = document.createElement('div');
        booksContainer.className = 'books-container';
        
        languageBooks.forEach(book => {
            const bookElement = document.createElement('div');
            bookElement.className = 'book';

            const img = document.createElement('img');
            // Check if cover is base64 data or path
            if (book.cover && book.cover.startsWith('data:')) {
                img.src = book.cover;
            } else {
                // Fallback to default cover if the base64 data is invalid
                img.src = 'images/default-cover.png';
                console.error('Invalid cover data for book:', book.filename);
            }
            img.alt = book.filename;
            
            const title = document.createElement('div');
            title.className = 'book-title';
            title.textContent = book.filename.replace('.epub', '');
            
            bookElement.appendChild(img);
            bookElement.appendChild(title);
            
            // Add click event to load the book (now using the async function)
            bookElement.addEventListener('click', async () => {
                    // Show loading indicator
                    title.textContent = "Loading...";
                    
                    // Request the specific book data
                    //const response = await wsConnection.request({
                    //    task: "get_book_data",
                    //    filename: book.filename,
                    //});
                    sendSocketMessage({
                        task: "get_book_data",
                        filename: book.filename,
                    });
                  
                    
                 
                    
                    
                
            });
            
            booksContainer.appendChild(bookElement);
        });
        
        languageSection.appendChild(booksContainer);
        booksGrid.appendChild(languageSection);
    });
}

function setLanguage(language){
    if (lang_conversion[language]) {
        return lang_conversion[language];
    }else{
        return language;
    }
}


function handleTranslationResponse(response) {
    // Handle translation response
    const translatedText = response.translation || response.translated_text;
    translation.innerHTML = translatedText;
    console.log("Updated translation with:", translatedText);
}

function handleTokenResponse(response) {
    console.log("Token response:", response);
    localStorage.setItem('token', response.token);
    username = response.username;
    console.log("username: ", username);
    
    // Standardize the language code
    if (response.language) {

        sourceLang = response.language;
        
        // Update language selector if it exists
        if (languageSel) {
            languageSel = setLanguage(sourceLang);
        }
    }
    
    // Update UI to show logged-in state - pass the response object
    updateAuthUI(true, response.username, response);
    
    // Close the settings drawer
    drawer.classList.remove('open');
}

function updateAuthUI(isLoggedIn, username = '', responseData = null) {
    const loginSignupContainer = document.getElementById('login-singup');
    const usernameInput = document.getElementById('user-name');
    const passwordInput = document.getElementById('user-password');
    
    if (isLoggedIn) {
        // Hide login/signup elements
        loginSignupContainer.style.display = 'none';
        usernameInput.style.display = 'none';
        passwordInput.style.display = 'none';
        sourceLang = responseData.language;
        languageSel = setLanguage(sourceLang);
        // Add logged-in user display
        const userInfoDiv = document.createElement('div');
        userInfoDiv.id = 'user-info';
        userInfoDiv.className = 'options';
        userInfoDiv.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <span>Logged in as: ${username}</span>
                <button id="logout-button" class="small-button">Logout</button>
            </div>
        `;
        
        // Insert after the login elements
        const settingsOptions = document.getElementById('settings-options');
        settingsOptions.insertBefore(userInfoDiv, document.getElementById('available-books'));
        
        // Add logout functionality
        document.getElementById('logout-button').addEventListener('click', handleLogout);

        // Load user's current book if available - use responseData instead of response
        if (responseData && responseData.current_book && responseData.epub) {
            selectedBook = responseData.current_book;
            selectedPage = responseData.page || 0;
            language = responseData.language;
            languageSel = setLanguage(language);
            console.log("Loading user's current book:", selectedBook);
            
            // Convert base64 to blob
            const base64Data = responseData.epub.split(',')[1];
            const mimeString = responseData.epub.split(',')[0].split(':')[1].split(';')[0];
            const byteString = atob(base64Data);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            
            // Render the book
            renderEpub(blob).then(() => {
                if (selectedPage && rendition) {
                    rendition.display(selectedPage);
                }
            }).catch(error => {
                console.error('Error rendering book:', error);
            });
        }
    } else {
        // Show login/signup elements
        loginSignupContainer.style.display = 'flex';
        usernameInput.style.display = 'block';
        passwordInput.style.display = 'block';
        
        // Remove user info if it exists
        const userInfo = document.getElementById('user-info');
        if (userInfo) {
            userInfo.remove();
        }
    }
}



// Update the translation function
async function updateTranslation(text) {
    console.log(`Translating text: "${text}" from ${sourceLang}`);
    
    translation.textContent = "Translating...";
    
    // Get user's native language from settings
    const targetLang = languageUserOptionsSelect.value;
    console.log("targetLang: ", targetLang);
    console.log("sourceLang: ", sourceLang);
    console.log("username: ", username);
    
    sendSocketMessage({ 
        task: 'translate', 
        text: text, 
        source_lang: sourceLang, 
        target_lang: targetLang, 
        current_book: selectedBook, 
        page: selectedPage,
        username: username 
    });
}

// Update the createBlobAndConnect function
function createBlobAndConnect() {
    const statusIndicator = document.getElementById('recording-status');
    if (statusIndicator) {
        statusIndicator.style.display = 'flex';
        // Start the timer
        processingStartTime = Date.now();
        updateTimer();
        timerInterval = setInterval(updateTimer, 100); // Update every 0.1 seconds
    }

    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
    audioChunks = []; // Clear the chunks array for next recording

    // Convert blob to base64
    const reader = new FileReader();
    reader.readAsDataURL(audioBlob);
    reader.onloadend = function() {
        const base64data = reader.result;
        
        // Log the current language value
        console.log("Current language value:", languageSel);
        console.log("Current sourceLang:", sourceLang);
       
        sendSocketMessage({ 
            task: 'stt', 
            blob: base64data, 
            language: languageSel, 
            sentence: lines[lineNum], 
            username: username, 
            book: selectedBook, 
            page: selectedPage 
        });
    };
}

// Add a function to verify token on page load
function verifyToken(token) {
    sendSocketMessage({
        task: "verify_token",
        token: token
    });
}

// Update token verification on page load
window.addEventListener('DOMContentLoaded', () => {
    initializeVoices();
    
    // Check for stored token and username
    const storedToken = localStorage.getItem('token');
    const storedUsername = localStorage.getItem('username');
    console.log("storedToken: ", storedToken);
    console.log("storedUsername: ", storedUsername);
    
    if (storedToken) {
        // Wait for WebSocket connection to be established
        if (socket.readyState === WebSocket.OPEN) {
            verifyToken(storedToken);
        } else {
            socket.addEventListener('open', () => {
                verifyToken(storedToken);
            }, { once: true });
        }
    }
});

// Add this new function to handle the prediction sentence
async function handlePredSentence(response) {
    console.log("handlePredSentence: ", response);
    predSentence = response.pred_sentence;
    console.log("predSentence: ", predSentence);
    returnSentenceDiv.innerHTML = predSentence;
    
    // Add click handlers to wrong words
    document.querySelectorAll('.wrong').forEach(wrongWord => {
        wrongWord.addEventListener('click', (event) => {
            // Remove 'pressed' class from all wrong words
            document.querySelectorAll('.wrong').forEach(w => w.classList.remove('pressed'));
            
            // Add 'pressed' class to clicked word
            wrongWord.classList.add('pressed');
            
            // Get the correct word from the ID
            const correctWord = wrongWord.id;
            console.log("Correct word:", correctWord);
            
            // Create popup with the correct word
            if (!popupflag) {
                createPopup(correctWord, event);
            }
        });
    });
    
    // Show points display when we get a response
    const pointsDisplay = document.getElementById('points-display');
    pointsDisplay.style.display = 'block';
    
    // Calculate and update points
    const wrongElements = document.getElementsByClassName("wrong");
    const totalWords = predSentence.split(' ').length;
    const correctWords = response.points;
    
    // Award points
    const pointsEarned = correctWords * 10;
    userPoints += pointsEarned;
    updatePointsDisplay(userPoints);
}

// Call loadAvailableBooks when the available books button is clicked
availableBooksBtn.addEventListener('click', () => {
    loadAvailableBooks();
    
});

// Close books modal
document.querySelectorAll('.modal .close').forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        closeBtn.closest('.modal').style.display = 'none';
    });
});
    // Separate function for epub rendering
    async function renderEpub(file) {
            currentBook = ePub(file);
            const viewer = document.getElementById("viewer");
            viewer.innerHTML = "";
            rendition = currentBook.renderTo("viewer", {
                height: "100%",
                width: "100%",
                allowScriptedContent: true,
                script: true,
                flow: "scrolled-doc",
                manager: "continuous"
            });
            
            rendition.display().then(() => {
                addClickHandlersToPage();
            });
            
            rendition.on("rendered", (section) => {
                selectedPage = section.href;
                addClickHandlersToPage();
            });
            
            // Function to add click handlers to the current page
            function addClickHandlersToPage() {
                const contents = rendition.getContents();
                
                contents.forEach(content => {
                    // Add CSS for pulsing animation to the document head
                    const style = content.document.createElement('style');
                    style.textContent = `
                        @keyframes pulse {
                            0% { background-color: transparent; }
                            50% { background-color: rgba(169, 209, 215, 0.3); }
                            100% { background-color: transparent; }
                        }
                        .pulse-animation {
                            animation: pulse 2s infinite;
                        }
                        .sentence-icon {
                            font-size: 16px;
                            margin-right: 4px;
                            vertical-align: middle;
                            display: inline-block;
                        }
                        .pulse-animation .sentence-icon {
                            opacity: 1 !important;
                        }
                    `;
                    content.document.head.appendChild(style);
                    
                    // Remove any existing pulse animations first
                    content.document.querySelectorAll('.pulse-animation').forEach(el => {
                        el.classList.remove('pulse-animation');
                        const icon = el.querySelector('.sentence-icon');
                        if (icon) {
                            icon.remove();
                        }
                    });
                    
                    let isFirstSentence = true;
                    
                    content.document.querySelectorAll('p, span').forEach((element, elementIndex) => {
                        if (element.dataset.processed === "true") return;
                        
                        // Skip if this is a title (text in all caps)
                        if (element.textContent.trim() === element.textContent.trim().toUpperCase()) {
                            element.dataset.processed = "true";
                            return;
                        }
                        
                        const sentences = element.textContent.split(/(?<=[.!?])\s+/);
                        if (sentences.length === 0) return;
                        
                        element.textContent = '';
                        element.dataset.processed = "true";
                        
                        sentences.forEach((sentence, index) => {
                            if (sentence.trim().length < 2) return;
                            
                            const sentenceSpan = content.document.createElement('span');
                            sentenceSpan.textContent = sentence + ' ';
                            sentenceSpan.style.cursor = 'pointer';
                            sentenceSpan.style.borderRadius = '3px';
                            sentenceSpan.style.transition = 'background-color 0.2s ease';
                            
                            // Only add the finger emoji to the first actual sentence
                            if (isFirstSentence && 
                                sentence.trim() !== sentence.trim().toUpperCase() && 
                                sentence.trim().length > 10) { // Basic check for actual sentence
                                const selectIcon = content.document.createElement('span');
                                selectIcon.textContent = '👉';
                                selectIcon.className = 'sentence-icon';
                                selectIcon.style.opacity = '1';
                                sentenceSpan.insertBefore(selectIcon, sentenceSpan.firstChild);
                                sentenceSpan.classList.add('pulse-animation');
                                isFirstSentence = false;
                            }
                            
                            // Add hover effects
                            sentenceSpan.addEventListener('mouseover', () => {
                                sentenceSpan.style.backgroundColor = 'rgba(169, 209, 215, 0.3)';
                            });
                            
                            sentenceSpan.addEventListener('mouseout', () => {
                                if (!sentenceSpan.classList.contains('selected-line')) {
                                    sentenceSpan.style.backgroundColor = 'transparent';
                                }
                            });
                            
                            // Add click handler
                            sentenceSpan.addEventListener('click', (event) => {
                                // Remove pulsing animation and icon from any sentence
                                content.document.querySelectorAll('.pulse-animation').forEach(el => {
                                    el.classList.remove('pulse-animation');
                                    const icon = el.querySelector('.sentence-icon');
                                    if (icon) {
                                        icon.remove();
                                    }
                                });
                                
                                // Remove previous selection
                                content.document.querySelectorAll('.selected-line').forEach(el => {
                                    el.classList.remove('selected-line');
                                    el.style.backgroundColor = 'transparent';
                                });
                                
                                // Add selection to clicked sentence
                                sentenceSpan.classList.add('selected-line');
                                sentenceSpan.style.backgroundColor = 'rgba(169, 209, 215, 0.5)';
                                
                                // Show modal with translation
                                const modal = document.getElementById('myModal');
                                const modalContent = modal.querySelector('.modal-content');
                                
                                // Calculate width for modal content
                                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                                
                                // Set modal content width
                                if (isMobile) {
                                    modalContent.style.width = `calc(100vw - 20px)`;
                                    modalContent.style.maxWidth = '100%';
                                } else {
                                    const modalWidth = Math.min(window.innerWidth - 40, 800);
                                    modalContent.style.width = `${modalWidth}px`;
                                }
                                
                                modal.style.display = 'block';
                                
                                // Update translation
                                selectedText = sentence.trim();
                                lines = [selectedText];
                                lineNum = 0;
                                updateTranslation(selectedText);
                                
                                event.stopPropagation();
                            });
                            
                            element.appendChild(sentenceSpan);
                        });
                    });
                });
            }
            
            fileDiv.style.display = "none";
            
            // Create scroll down button if it doesn't exist
            if (!document.getElementById('scroll-down-btn')) {
                const scrollBtn = document.createElement('button');
                scrollBtn.id = 'scroll-down-btn';
                scrollBtn.textContent = 'Load More';
                scrollBtn.style.position = 'absolute';
                scrollBtn.style.bottom = '10px';
                scrollBtn.style.left = '50%';
                scrollBtn.style.transform = 'translateX(-50%)';
                scrollBtn.style.zIndex = '100';
                scrollBtn.style.padding = '10px 20px';
                scrollBtn.style.backgroundColor = '#007bff';
                scrollBtn.style.color = 'white';
                scrollBtn.style.border = 'none';
                scrollBtn.style.borderRadius = '5px';
                scrollBtn.style.cursor = 'pointer';
                scrollBtn.style.marginBottom = '10px';
                
                scrollBtn.onclick = () => {
                    // Get all iframe contents
                    const contents = rendition.getContents();
                    if (contents && contents.length > 0) {
                        // For each content iframe
                        contents.forEach(content => {
                            const iframe = content.document.defaultView;
                            // Scroll down by 80% of the viewport height
                            const scrollAmount = iframe.innerHeight * 0.8;
                            iframe.scrollBy({
                                top: scrollAmount,
                                behavior: 'smooth'
                            });
                        });
                        
                        // After scrolling, try to load more content if needed
                        setTimeout(() => {
                            // If we're near the bottom, load more
                            const lastContent = contents[contents.length - 1];
                            const iframe = lastContent.document.defaultView;
                            const scrollPos = iframe.scrollY + iframe.innerHeight;
                            const scrollHeight = lastContent.document.body.scrollHeight;
                            
                            if (scrollHeight - scrollPos < iframe.innerHeight * 0.2) {
                                console.log("Near bottom, attempting to load more content");
                                rendition.next();
                            }
                        }, 300);
                        scrollBtn.style.display = 'none';
                    }
                };
                
                // Append to div2viewer instead of body
                const div2viewer = document.getElementById('div2viewer');
                div2viewer.appendChild(scrollBtn);
                
                // Make sure div2viewer has a position for absolute positioning to work properly
                div2viewer.style.position = div2viewer.style.position || 'relative';
            }
    }

    recordBtn.addEventListener('click', async () => { //standarised procedure 
        if (!isRecording) {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); //built-in function of mozilla to get the media of the user
            mediaRecorder = new MediaRecorder(stream); //object pre-built
            
            mediaRecorder.ondataavailable = event => { //event = the object has changed in some way. every ms that you talk and it gets saved in the array
                audioChunks.push(event.data);  //saving the audio into an array
            };

            mediaRecorder.start();
            recordBtn.src = "images/stopRecButton.png";
            //socket.send(JSON.stringify({ event: 'start' })); // Notify server that recording has started
            isRecording=true;

         } else {   //this means that isRecording==true;
            mediaRecorder.stop(); 
            isRecording=false;
            recordBtn.src = "images/recordingButton.png";
         }        
        mediaRecorder.onstop = () => {
            createBlobAndConnect(); // Call the function to create the blob and connect
            //socket.send(JSON.stringify({ event: 'stop' })); // Notify server that recording has stopped
        };

       
    });

    const closeModalBtn = document.querySelector('.close-modal');

    // Add event listener for the new close button
    closeModalBtn.addEventListener('click', () => {
        modalDiv.style.display = "none";
        lineNum = 0;
        
        // Hide points display when modal closes
        const pointsDisplay = document.getElementById('points-display');
        pointsDisplay.style.display = 'none';
    });

    // Close modal when clicking outside
    window.addEventListener('click',(event)=> {
        if (event.target==modalDiv) {
            modalDiv.style.display = "none";
        }
    });

    fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
            try {
                await renderEpub(file);
            } catch (error) {
                console.error('Error handling file:', error);
            }
        }
    });

    fileDiv.addEventListener('click',()=> {
        fileInput.click();
    })

    settingsBtn.addEventListener('click', (event) => {
        console.log("settings button clicked");
        console.log("Drawer classList before:", drawer.classList);
        drawer.style.display = 'block';  // First set display to block
        setTimeout(() => {
            drawer.classList.add('open'); // Then add the open class
        }, 10);
        event.stopPropagation();
    });

    closeDrawerBtn.addEventListener('click', () => {
        console.log("close button clicked");
        drawer.classList.remove('open');
        setTimeout(() => {
            drawer.style.display = 'none';
        }, 300); // Wait for transition to complete
    });

    window.addEventListener('click', (event) => {
        // Check if the click was on the settings button or its children (like the image)
        if (!drawer.contains(event.target) && !settingsBtn.contains(event.target)) {
            drawer.classList.remove('open');
            setTimeout(() => {
                drawer.style.display = 'none';
            }, 300); // Wait for transition to complete
        }
    });

    // Make sure the drawer starts hidden
    drawer.style.display = 'none';

    textToSpeechBtn.addEventListener('click', () => {
        if ('speechSynthesis' in window) {
            const isCurrentlySpeaking = textToSpeechBtn.getAttribute('data-speaking') === 'true';
            
            if (isCurrentlySpeaking) {
                // Stop speaking and reset the button
                window.speechSynthesis.cancel();
                textToSpeechBtn.setAttribute('data-speaking', 'false');
                textToSpeechBtn.style.filter = 'brightness(1)';
            } else {
                // Start speaking and darken the button
                textToSpeechBtn.setAttribute('data-speaking', 'true');
                textToSpeechBtn.style.filter = 'brightness(0.7)';
                textToSpeech(lines[lineNum]);
            }
        } else {
            console.log("Sorry, your browser doesn't support text to speech!");
        }
    });
    
    
    function randomLanguage(){
        const languages = ['en', 'es', 'fr', 'de', 'it'];
        return languages[Math.floor(Math.random() * languages.length)];
    }

    function textToSpeech(textToSpeak) {
        if ('speechSynthesis' in window) {
            console.log('Starting text-to-speech for:', textToSpeak);
            
            let msg = new SpeechSynthesisUtterance();
            msg.text = textToSpeak;
            
            // Make sure we're using the correct language
            const currentLang = languageSel.substring(0,2);
            console.log('Using language:', currentLang);
            msg.lang = currentLang;
            
            // Match the settings from the robot button
            msg.rate = 1;
            msg.volume = 1;
            msg.pitch = 1;
            
            // Select a voice based on gender preference
            const voices = window.speechSynthesis.getVoices();
            
            // Filter voices by language and gender
            const matchingVoices = voices.filter(voice => {
                // Check if voice language matches or contains our target language
                const voiceLang = voice.lang.toLowerCase();
                const targetLang = currentLang.toLowerCase();
                const langMatch = voiceLang.startsWith(targetLang) || voiceLang.includes(targetLang);
                
                // Determine gender based on voice name (common pattern in voice APIs)
                // This is a heuristic and may not be 100% accurate
                const isFemaleName = voice.name.toLowerCase().includes('female') || 
                                   voice.name.toLowerCase().includes('woman') ||
                                   voice.name.toLowerCase().includes('girl') ||
                                   voice.name.toLowerCase().includes('fiona') ||
                                   voice.name.toLowerCase().includes('samantha') ||
                                   voice.name.toLowerCase().includes('victoria');
                                   
                const isMaleName = voice.name.toLowerCase().includes('male') || 
                                 voice.name.toLowerCase().includes('man') ||
                                 voice.name.toLowerCase().includes('guy') ||
                                 voice.name.toLowerCase().includes('david') ||
                                 voice.name.toLowerCase().includes('thomas') ||
                                 voice.name.toLowerCase().includes('daniel');
                
                // Match based on selected gender
                const genderMatch = (selectedVoiceGender === 'female' && isFemaleName) || 
                                  (selectedVoiceGender === 'male' && isMaleName);
                
                return langMatch && genderMatch;
            });
            
            console.log(`Found ${matchingVoices.length} matching voices for ${currentLang} and gender ${selectedVoiceGender}`);
            
            // Use the first matching voice, or fall back to default
            if (matchingVoices.length > 0) {
                msg.voice = matchingVoices[0];
                console.log("Selected voice:", msg.voice.name);
            } else {
                console.log("No matching voice found, using default");
            }
            
            // Add event listeners to debug TTS issues
            msg.onstart = () => console.log('Speech started');
            msg.onend = () => {
                console.log('Speech ended');
                textToSpeechBtn.setAttribute('data-speaking', 'false');
                textToSpeechBtn.style.filter = 'brightness(1)';
            };
            msg.onerror = (e) => {
                console.error('Speech error:', e);
                textToSpeechBtn.setAttribute('data-speaking', 'false');
                textToSpeechBtn.style.filter = 'brightness(1)';
            };
            
            window.speechSynthesis.speak(msg);
        } else {
            console.error("Speech synthesis not supported in this browser");
        }
    }
    
    function createPopup(content, event) {
        // Remove any existing popups first
        document.querySelectorAll('.popup').forEach(popup => popup.remove());
        
        const popup = document.createElement('div');
        const closePopupButton = document.createElement('span');
        const contentElement = document.createElement('p');
        
        // Style the close button
        closePopupButton.innerHTML = '&times;';
        closePopupButton.style.position = 'absolute';
        closePopupButton.style.top = '5px';
        closePopupButton.style.right = '10px';
        closePopupButton.style.cursor = 'pointer';
        closePopupButton.style.fontSize = '18px';
        closePopupButton.style.fontWeight = 'bold';
        closePopupButton.classList.add('popup-close');
        
        contentElement.textContent = content;
        
        popup.appendChild(contentElement);
        popup.appendChild(closePopupButton);
        
        closePopupButton.addEventListener('click', (e) => {
            popup.remove();
            popupflag = false;
            e.stopPropagation();
        });
        popup.addEventListener('click', (e) => {
            popup.remove();
            popupflag = false;
            e.stopPropagation();
        });
        
        // Get click/touch position
        const x = event.clientX || (event.touches && event.touches[0].clientX) || 0;
        const y = event.clientY || (event.touches && event.touches[0].clientY) || 0;
        
        popup.style.position = 'absolute'; 
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`; 
        popup.classList.add('popup');
        
        document.body.appendChild(popup);
        popup.style.zIndex = 1000;
        
        // Use the correct word for TTS
        if (content) {
            console.log("Speaking correct word:", content);
            textToSpeech(content);
        } else {
            console.error("No content to speak");
        }
        
        popupflag = true;
    }
    
    // Add a global click event listener to document
    document.addEventListener('click', (event) => {
        const popups = document.querySelectorAll('.popup');
        if (popups.length > 0) {
            // Check if the click was inside a popup or on a wrong element
            const clickedInsidePopup = Array.from(popups).some(popup => popup.contains(event.target));
            const clickedOnWrongElement = event.target.classList.contains('wrong');
            const clickedOnPopupClose = event.target.classList.contains('popup-close');
            
            // If clicked outside popup and not on a wrong element, remove all popups
            if (!clickedInsidePopup && !clickedOnWrongElement && !clickedOnPopupClose) {
                popups.forEach(popup => popup.remove());
                popupflag = false;
            }
        }
    });

    function openUserAccount() {
        document.getElementById('user-modal').style.display = 'block';
       }

    function initializeVoices() {
        // Get the available voices
        availableVoices = window.speechSynthesis.getVoices();
        
        // If voices aren't loaded yet, wait for them
        if (availableVoices.length === 0) {
            window.speechSynthesis.addEventListener('voiceschanged', () => {
                availableVoices = window.speechSynthesis.getVoices();
                console.log("Available voices:", availableVoices);
            }, { once: true }); // Add the 'once' option to only trigger this once
        } else {
            console.log("Available voices:", availableVoices);
        }
    }

    // Add event listener for voice gender selection
    voiceGenderDisplay.addEventListener('click', () => {
        if (voiceGenderOptionsOpen) {
            voiceGenderOptionsOpen = false;
            voiceGenderSelect.style.transform = 'translateX(1000%)';
        } else {
            voiceGenderSelect.style.transform = 'translateX(0)';
            voiceGenderOptionsOpen = true;
        }
    });

    // Update selected voice gender when changed
    voiceGenderSelect.addEventListener('change', () => {
        selectedVoiceGender = voiceGenderSelect.value;
        console.log("Selected voice gender:", selectedVoiceGender);
    });

    // Add event listener for text selection in the viewer
    const viewerElement = document.getElementById('viewer');
    if (viewerElement) {
        viewerElement.addEventListener('mouseup', handleTextSelection);
        viewerElement.addEventListener('touchend', handleTextSelection);
    }
    


    function handleTextSelection() {
        const selection = window.getSelection();
        const text = selection.toString().trim();
        
        if (text && text.length > 0) {
            console.log("Selected text:", text);
            selectedText = text;
            modalDiv.style.display = "block";
            sourceLang = languageSel;
            languageSel = setLanguage(sourceLang);
            translationText = text;
            updateTranslation(text);
        }
    }

    // Fix the extractVisibleText function to handle errors better
    function extractVisibleText() {
        console.log("extractVisibleText called");
        const location = rendition.currentLocation();
        console.log("Current location:", location);

        const makeRangeCfi = (a, b) => {
                const CFI = new ePub.CFI()
                const start = CFI.parse(a), end = CFI.parse(b)
                const cfi = {
                    range: true,
                    base: start.base,
                    path: {
                        steps: [],
                        terminal: null
                    },
                    start: start.path,
                    end: end.path
                }
                const len = cfi.start.steps.length
                for (let i = 0; i < len; i++) {
                    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
                        if (i == len - 1) {
                            if (cfi.start.terminal === cfi.end.terminal) {
                                cfi.path.steps.push(cfi.start.steps[i])
                                cfi.range = false
                            }
                        } else cfi.path.steps.push(cfi.start.steps[i])
                    } else break
                }
                cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)
                cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)

                return 'epubcfi(' + CFI.segmentString(cfi.base)
                    + '!' + CFI.segmentString(cfi.path)
                    + ',' + CFI.segmentString(cfi.start)
                    + ',' + CFI.segmentString(cfi.end)
                    + ')'
            }

        if (location && location.start && location.end) {
            const rangeCfi = makeRangeCfi(location.start.cfi, location.end.cfi);
            console.log("Range CFI created:", rangeCfi);
            
            currentBook.getRange(rangeCfi)
                .then(range => {
                    if (range) {
                        selectedText = range.toString();
                        console.log("Raw selected text:", selectedText);
                        
                        // Clean up text
                        selectedText = cleanText(selectedText);
                        console.log("Cleaned selected text:", selectedText);
                        
                        lines = selectedText.split('.')
                            .map(line => line.trim())
                            .filter(line => line.length > 0)
                            .map(line => line + '.');
                        
                        console.log("Lines array:", lines);
                        console.log("Number of lines:", lines.length);
                    } else {
                        console.log("Range is null or undefined");
                    }
                })
                .catch(error => {
                    console.error('Error getting range:', error);
                    // Initialize empty lines array to prevent further errors
                    lines = [];
                });
        } else {
            console.log("Location is invalid:", location);
        }
    }
    
    // Separate text cleaning function
    function cleanText(text) {
        const regexMatch = /[A-Z]\./g;
        text = text.replace(regexMatch, match => match.replace('.', ''));
        
        abbreviations.forEach(abbr => {
            let clean = abbr.replaceAll(".", "");
            text = text.replaceAll(abbr, clean);
        });
        
        return text;
    }

    function isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    // Add this function to handle book data responses
    function handleBookDataResponse(response) {
            console.log("response:", response);

        
          

            // Set selectedBook from the response filename
            selectedBook = response.filename;
            console.log("Set selectedBook:", selectedBook);

            // Set language from response
            sourceLang = response.language;
            languageSel = setLanguage(sourceLang);
            console.log("epub:", response.epub);
            const base64Data = response.epub.split(',')[1];
            console.log("Base64 data:", base64Data);
            if (!base64Data) {
                throw new Error('Invalid EPUB data format');
            }

            const mimeString = response.epub.split(',')[0].split(':')[1].split(';')[0];
            const byteString = atob(base64Data);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            
            // Render the book
            renderEpub(blob).then(() => {
                if (response.page) {
                    rendition.display(response.page);
                }
                if (booksModal) {
                    booksModal.style.display = 'none';
                }
            }).catch(error => {
                console.error('Error rendering book:', error);
                alert('Error rendering book: ' + error.message);
            });

    
    }

    // Select all elements with the 'close' class
    const closeButtons = document.getElementsByClassName('close');

    // Add click event listener to each close button
    Array.from(closeButtons).forEach(closeBtn => {
        closeBtn.addEventListener('click', () => {
            // Find the closest parent modal/drawer
            const container = closeBtn.closest('.modal, .drawer, #books-modal');
            if (container) {
                container.style.display = 'none';
            }
        });
    });

    function updatePointsDisplay(points) {
        // Update all points displays
        const pointsDisplays = document.querySelectorAll('#points');
        pointsDisplays.forEach(element => {
            element.textContent = points;
        });

        // Make sure points display is visible
        const pointsDisplayDivs = document.querySelectorAll('#points-display');
        pointsDisplayDivs.forEach(div => {
            div.style.display = 'block';
            div.style.textAlign = 'center';
            div.style.fontSize = '1em';
            div.style.fontWeight = 'bold';
        });
    }

    // Add this new function
    function updateTimer() {
        const timerElement = document.querySelector('.timer');
        if (timerElement && processingStartTime) {
            const elapsedTime = (Date.now() - processingStartTime) / 1000; // Convert to seconds
            timerElement.textContent = `${elapsedTime.toFixed(1)}s`;
        }
    }

    feedbackBtn.addEventListener('click', async () => {
        feedbackModal.style.display = 'block';
        
        
    });

    sendFeedbackBtn.addEventListener('click', () => {
        feedbackModal.style.display = 'none';
        //console.log("sendFeedbackBtn clicked");
        //const message = {
        //    task: "get_survey"
        //};
        //sendSocketMessage(JSON.stringify(message));
    });


</script>
