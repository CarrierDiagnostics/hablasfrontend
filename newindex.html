<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
<link href="https://fonts.googleapis.com/css2%3Ffamily=Lato:wght@400%3B700&amp;family=Roboto:wght@400%3B700&amp;family=Quicksand:wght@400%3B700&amp;family=Montserrat:wght@400%3B700&amp;display=swap.css" rel="stylesheet">
<link rel="stylesheet" href="style.css">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Hablas - Language Learning</title>
    <style>
        /* Additional styles for pagele functionality */
        .hold-button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: background-color 0.2s;
        }
        
        .hold-button:active {
            background-color: #0056b3;
        }

        .sentence-info-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(50%);
        }
        
        #init-login-section {
            margin-top: 20px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            width: 80%;
            max-width: 400px;
        }
        
        #init-login-section input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        
        #init-login-section .options {
            padding: 10px;
            text-align: center;
            background-color: #4CAF50;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #init-login-section .options:hover {
            background-color: #45a049;
        }

        /* Tip section styles */
        .tip-amounts {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .tip-button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tip-button:hover {
            background: #f0f0f0;
        }
        
        #tip-custom {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        #custom-tip {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        #payment-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9001;
            overflow-y: auto;
        }
        
        #payment-modal .modal-content {
            background: white;
            margin: 15% auto;
            padding: 20px;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            overflow-y: auto;
        }
        
        #payment-element {
            margin: 20px 0;
        }
        
        #submit-payment {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        
        #submit-payment:hover {
            background: #45a049;
        }
        
        #payment-message {
            margin-top: 10px;
            color: #666;
        }

        /* Mode selection styles */
        .mode-container {
            display: none;
        }
        
        .mode-container.active {
            display: block;
        }

        /* Bug report button styling */
        #found-bug {
            background-color: #ff6b6b !important;
            color: white !important;
            border: 1px solid #ff5252 !important;
        }
        
        #found-bug:hover {
            background-color: #ff5252 !important;
        }
    </style>
</head>
<body>
    <div id="title">
        <p>Hablas</p>
        <div id="title-right">
            <div id="user-section">Login</div>
            <img src="images/settings.png" id="settings"/> 
        </div>
    </div>

    <!-- Initial choice screen -->
    <div id="initChoice">
        <div id="initDailypages" class="disabled">Daily pages</div>
        <div id="initFreeRead" class="disabled">Free read</div>
        
        <div id="init-login-section">
            <h3>Please log in to start</h3>
            <input type="text" id="init-user-name" placeholder="Email">
            <input type="password" id="init-user-password" placeholder="Password">
            <div id="init-login-signup" style="display: flex; width: 100%; gap: 10px; margin-top: 10px;">
                <div id="init-login-button" class="options" style="flex: 1;">Login</div>
                <div id="init-signup-button" class="options" style="flex: 1;">Sign up</div>
            </div>
        </div>
    </div>

    <!-- Free reading container -->
    <div id="div2viewer" class="mode-container">
        <div id="viewer">
            <div id="empty-viewer-message">
                <p></p>
                <button id="browse-books-btn" onclick="loadAvailableBooks()">Tap here to begin!</button>
            </div>
        </div>
    </div>

    <!-- Daily pages container -->
    <div id="pagele-content" class="mode-container">
        <!-- Pagele Selection Modal -->
        <div id="pagele-modal" class="modal">
            <span class="close">&times;</span>
            <h2>Select a Pagele</h2>
            <div id="pagele-list-container">
                <div id="pagele-list"></div>
            </div>
        </div>
        
        <!-- Chapters Grid Modal -->
        <div id="chapters-modal" class="modal">
            <span id="close-chapters-modal" class="close">&times;</span>
            <h2>Chapters</h2>
            <div id="chapters-grid"></div>
        </div>
        
        <!-- Sentence Display Modal -->
        <div id="sentence-modal" class="modal">
            <div class="sentence-info-container">
                <button id="translation-btn" class="hold-button">Translate</button>
                <h2 id="chapter-title">Chapter Title</h2>
                <span id="close-sentence-modal" class="close">&times;</span>
            </div>
            <div id="sentence-container"></div>
            <div id="prediction-container"></div>
            <div class="sentence-info-container">
                <span id="sentence-counter">1/10</span>
                <span id="points-display-pagele">Points: </span><span id="points-pagele">0</span>
            </div>
            <div id="actionButtons">
                <img id="prev-sentence" src="images/arrow-left.png" alt="prev-sentence"/>
                <img id="record-pagele" src="images/recordingButton.png" alt="record icon"/>
                <img id="robot-pagele" src="images/robot_talk_white.png" alt="robot" data-speaking="false"/>
                <img id="next-sentence" src="images/arrow-right.png" alt="next-sentence"/>
                
                <div id="recording-status-pagele" style="display: none;">
                    <div class="status-spinner"></div>
                    <div class="status-message">Processing...</div>
                    <div class="timer">0.0s</div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".epub" style="display: none;"/>
     
    <!-- Settings drawer -->
    <div id="settings-drawer" class="drawer">
        <span id="close-drawer" class="close">&times;</span>
        <h2>Settings</h2>
        <div id="settings-options">
            <input type="text" id="user-name" placeholder="Email">
            <input type="password" id="user-password" placeholder="Password">
            <div id="login-singup" style="display: flex; width: 100%; gap: 10px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">
                <div id="login-button" class="options" style="flex: 1;">Login</div>
                <div id="signup-button" class="options" style="flex: 1;">Sign up</div>
            </div>
            <div id="mode-switch" class="options">Switch to <span id="mode-text">Daily Pages</span></div>
            <div id="available-books" class="options">Available books</div>
            <div id="available-pagele" class="options">Available daily pages</div>
            <div id="userLanguages" class="options">Native Language</div>
            <select id="languageUserOptions" default="en" class="settings-select">
                <option value="en">English</option>
                <option value="es">Español</option> 
                <option value="fr">Français</option>
                <option value="de">Deutsch</option>
                <option value="it">Italiano</option>
                <option value="pt">Português</option>
                <option value="ru">Русский</option>
                <option value="zh-cn">中文 (简体)</option>
                <option value="ja">日本語</option>
                <option value="ko">한국어</option>
                <option value="ar">العربية</option>
                <option value="hi">हिन्दी</option>
                <option value="nl">Nederlands</option>
                <option value="sv">Svenska</option>
                <option value="pl">Polski</option>
                <option value="tr">Türkçe</option>
                <option value="th">ไทย</option>
                <option value="vi">Tiếng Việt</option>
            </select>
            <div id="tutorial" class="options">Tutorial</div>
            <div id="found-bug" class="options">Found a bug</div>
            <div id="tip-section" class="options">
                <h3>Support Hablas</h3>
                <div class="tip-amounts">
                    <button class="tip-button" data-amount="1">£1</button>
                    <button class="tip-button" data-amount="3">£3</button>
                    <button class="tip-button" data-amount="5">£5</button>
                    <button class="tip-button" data-amount="10">£10</button>
                </div>
                <div id="tip-custom">
                    <input type="number" id="custom-tip" min="1" step="1" placeholder="Custom amount">
                    <button id="custom-tip-button">Tip</button>
                </div>
            </div>
            <div id="file">
                <img src="images/upload-icon-white.png" alt="upload symbol" />
                <img src="images/epub-icon-white.png" alt="upload symbol" />
            </div>
        </div>
    </div>

    <!-- Books modal -->
    <div id="books-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="books-grid"></div>
        </div>
    </div>

    <!-- Translation modal -->
    <div id="myModal" class="modal"> 
        <div class="modal-content" id="modal-content"> 
            <span class="close-modal">&times;</span>
            <div id="modal-main">
                <div id="translation"></div>
                <div id="return_sentence">>></div>
            </div>

            <div id="actionButtons" style="position: relative;">
                <img id="record" src="images/recordingButton.png" alt="record icon"/>
                <img id="robot" src="images/robot_talk_white.png" alt="robot" data-speaking="false"/>
                <div id="points-display">Points: <span id="points">0</span></div>
                
                <div id="recording-status" style="
                    display: none;
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: rgba(0, 0, 0, 0.7);
                    /* Ensure it's using flex to center content, as per JS */
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;">
                    <div class="status-spinner"></div>
                    <div class="status-message">Processing...</div>
                    <div class="timer">0.0s</div>
                </div>
            </div>
        </div>
    </div>

    <!-- User account options modal -->
    <div id="user-account-options-modal" class="modal user-account-options-modal">
        <div class="modal-content user-account-options-modal-content">
            <span class="close options-close">&times;</span>
            <p>User account options</p>
            <button id="change-info-button">Change info</button>
            <button id="delete-account-button">Delete account</button>
        </div>
    </div>

    <!-- Tutorial modal -->
    <div id="tutorialModal" class="modal">
        <span class="close">&times;</span>
        <div id="tutorial-content" class="modal-content">
            <div class="loading-spinner">Loading...</div>
        </div>
    </div>

  

    <div id="fetching-data-status" style="
    display: none; 
    position: fixed; /* Fixed to cover viewport */
    top: 0; 
    left: 0; 
    right: 0; 
    bottom: 0; 
    background-color: rgba(0, 0, 0, 0.7); 
    /* Ensure it's using flex to center content, as per JS */
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    z-index: 2000; /* High z-index to be on top */
    color: white;
    ">
    <div class="status-spinner"></div> <!-- Reuse your existing spinner style if you have one -->
    <div class="status-message">Fetching data...</div>
</div>

    <!-- Payment modal -->
    <div id="payment-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Complete Your Tip</h2>
            <div id="payment-element"></div>
            <button id="submit-payment">Pay Now</button>
            <div id="payment-message"></div>
        </div>
    </div>

    <script src="https://js.stripe.com/v3/"></script>

    <script>
        // Global variables
        const EVENT_TYPE = ('ontouchstart' in window) ? 'touchend' : 'click';
        
        // Logging system
        let sessionLogs = [];
        const maxLogs = 1000; // Limit to prevent memory issues
        
        // Create hidden div for logs
        const logContainer = document.createElement('div');
        logContainer.id = 'session-logs';
        logContainer.style.display = 'none';
        document.body.appendChild(logContainer);
        
        // Function to add log entry
        function addLogEntry(type, message, ...args) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp,
                type,
                message: typeof message === 'string' ? message : JSON.stringify(message),
                args: args.length > 0 ? args.map(arg => typeof arg === 'string' ? arg : JSON.stringify(arg)) : []
            };
            
            sessionLogs.push(logEntry);
            
            // Keep only the last maxLogs entries
            if (sessionLogs.length > maxLogs) {
                sessionLogs = sessionLogs.slice(-maxLogs);
            }
            
            // Update hidden div
            const logElement = document.createElement('div');
            logElement.textContent = `[${timestamp}] ${type.toUpperCase()}: ${logEntry.message} ${logEntry.args.join(' ')}`;
            logContainer.appendChild(logElement);
            
            // Keep only the last maxLogs elements in DOM
            while (logContainer.children.length > maxLogs) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }
        
        // Override console methods
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info,
            debug: console.debug
        };
        
        console.log = function(message, ...args) {
            addLogEntry('log', message, ...args);
            originalConsole.log(message, ...args);
        };
        
        console.error = function(message, ...args) {
            addLogEntry('error', message, ...args);
            originalConsole.error(message, ...args);
        };
        
        console.warn = function(message, ...args) {
            addLogEntry('warn', message, ...args);
            originalConsole.warn(message, ...args);
        };
        
        console.info = function(message, ...args) {
            addLogEntry('info', message, ...args);
            originalConsole.info(message, ...args);
        };
        
        console.debug = function(message, ...args) {
            addLogEntry('debug', message, ...args);
            originalConsole.debug(message, ...args);
        };
        
        // Capture window errors
        window.addEventListener('error', function(event) {
            addLogEntry('error', `Uncaught error: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, event.error?.stack || '');
        });
        
        // Capture unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            addLogEntry('error', `Unhandled promise rejection: ${event.reason}`, event.reason?.stack || '');
        });
        
        // Function to manually log important events (use this for specific tracking)
        function logEvent(message, data = null) {
            const logMessage = data ? `${message} | Data: ${JSON.stringify(data)}` : message;
            addLogEntry('event', logMessage);
        }
        
        console.log(`Using ${EVENT_TYPE} events for this device`);

        // Touch/scroll detection for mobile
        let touchStartTime = 0;
        let touchStartY = 0;
        let touchStartX = 0;
        let touchMoved = false;

        function createTouchAwareEventListener(callback) {
            if ('ontouchstart' in window) {
                return function(element) {
                    let localTouchMoved = false;
                    let localTouchStartY = 0;
                    let localTouchStartX = 0;
                    let localTouchStartTime = 0;

                    element.addEventListener('touchstart', (e) => {
                        localTouchMoved = false;
                        const touch = e.touches[0];
                        localTouchStartY = touch.clientY;
                        localTouchStartX = touch.clientX;
                        localTouchStartTime = Date.now();
                    }, { passive: true });

                    element.addEventListener('touchmove', (e) => {
                        if (e.touches.length > 0) {
                            const touch = e.touches[0];
                            const deltaY = Math.abs(touch.clientY - localTouchStartY);
                            const deltaX = Math.abs(touch.clientX - localTouchStartX);
                            
                            // Consider it a move if finger moved more than 10px in any direction
                            if (deltaY > 10 || deltaX > 10) {
                                localTouchMoved = true;
                            }
                        }
                    }, { passive: true });

                    element.addEventListener('touchend', (e) => {
                        const touchDuration = Date.now() - localTouchStartTime;
                        
                        // Only trigger if:
                        // 1. User didn't move much (not scrolling)
                        // 2. Touch was quick (less than 500ms)
                        if (!localTouchMoved && touchDuration < 500) {
                            setTimeout(() => {
                                if (!localTouchMoved) { // Double check after a brief delay
                                    callback(e);
                                }
                            }, 50); // Small delay to ensure scroll hasn't started
                        }
                    }, { passive: true });
                };
            } else {
                // For non-touch devices, use regular click
                return function(element) {
                    element.addEventListener('click', callback);
                };
            }
        }

        // Mode management
        let currentMode = 'init'; // 'init', 'freeread', 'pagele'
        
        // Common variables
        let currentBook = null;
        let rendition = null;
        let selectedText = null;
        let lines = []; 
        let lineNum = 0;
        let language = "";
        let isRecording = false; 
        let translationText = "";
        let mediaRecorder; 
        let audioChunks = [];
        let userPoints = 0;
        let cfi = null;
        let username = '';
        let password = '';
        let sourceLang = "";
        let languageSel = "en";
        let selectedBook = null;
        let selectedPage = null;
        let currentAudio = null;
        let processingStartTime = 0;
        let timerInterval = null;
        let currentSentenceIndex = 0;
        let allSentences = [];
        let totalDailySentences = 10;
        let currentDailySentences = [];
        let lastSentencePosition = 0;
        let sentenceToTranslate = "";
        let dailyTranslationSentence = "translating daily sentence...";
        let positionFirstDailySentence = 0;
        let popupflag = false;

        // Pagele-specific variables
        let completedIndices = {};
        let pageleFilename = "";
        let pagele_language = 'en';
        let currentChapter = null;
        let pagele_data = null;
        let translated_text = "";
        let translate_down = false;
        let isLoggedIn = false;
        let userInfo = { username: '', points: 0 };
        let currentRequestStartTime = null;
        let currentRequestTask = '';
        let ttsCache = {};
        let lastTtsRequestDetails = null;

        // Language mappings
        const lang_conversion = {
            "francais": "fr",
            "english": "en",
            "español": "es",
            "espagnol": "es",
            "spanish": "es",
            "deutsch": "de",
            "italiano": "it",
            "turkish": "tr",
            'french': 'fr',
            'italian': 'it',
            'italiano': 'it',
            'portuguese': 'pt',
        };

        // Interface language strings
        let currentInterfaceLanguage = 'en';
        let interfaceStrings = {
            en: {
                appTitle: "Hablas",
                login: "Login",
                signup: "Sign up",
                dailyPages: "Daily pages",
                freeRead: "Free read",
                pleaseLoginToStart: "Please log in to start",
                email: "Email",
                password: "Password",
                settings: "Settings",
                switchToMode: "Switch to",
                nativeLanguage: "Native Language",
                tutorial: "Tutorial",
                supportHablas: "Support Hablas",
                foundABug: "Found a bug",
                sendingBugReport: "Sending bug report...",
                bugReportSent: "Bug report sent! Thank you for helping us improve.",
                bugReportError: "Error sending bug report. Please try again.",
                tapToBegin: "Tap here to begin!",
                selectPagele: "Select a Pagele",
                chapters: "Chapters",
                translate: "Translate",
                loading: "Loading...",
                translating: "Translating...",
                processing: "Processing...",
                fetchingData: "Fetching data...",
                parsingData: "Parsing data...",
                loadMore: "Load More",
                chapterTitle: "Chapter Title",
                points: "Points",
                prevSentence: "Previous",
                nextSentence: "Next",
                loggedInAs: "Logged in as",
                logout: "Logout",
                changeInfo: "Change info",
                deleteAccount: "Delete account",
                userAccountOptions: "User account options",
                completeYourTip: "Complete Your Tip",
                payNow: "Pay Now",
                customAmount: "Custom amount",
                tip: "Tip",
                thankYouForTip: "Thank you for your tip!",
                invalidCredentials: "Invalid credentials, have you signed up?",
                sessionExpired: "Your session has expired. Please log in again.",
                enterValidEmail: "Please enter a valid email address",
                passwordCannotBeEmpty: "Password cannot be empty",
                microphonePermissionRequired: "Microphone permission is required for recording.",
                couldNotAccessMicrophone: "Could not access microphone. Please check your browser permissions.",
                failedToStartRecording: "Failed to start recording. Please try again.",
                enterValidAmount: "Please enter a valid amount",
                errorLoadingTutorial: "Error loading tutorial content",
                pleaseTryAgain: "Please try again later.",
                noSentencesAvailable: "No sentences available for this chapter.",
                noChaptersAvailable: "No chapters available.",
                noPageleBooksAvailable: "No pagele books available.",
                reachedEndOfBook: "Reached end of book",
                errorRenderingBook: "Error rendering book",
                errorProcessingTip: "Error processing tip. Please try again."
            }
        };

        // Function to update interface language
        function updateInterfaceLanguage(langCode) {
            currentInterfaceLanguage = langCode;
            if (!interfaceStrings[langCode]) {
                console.log('Fetching interface strings for language:', langCode);
                requestInterfaceStrings(langCode);
            } else {
                applyInterfaceStrings(interfaceStrings[langCode]);
            }
        }

        // Function to request interface strings from server
        function requestInterfaceStrings(langCode) {
            sendSocketMessage({
                task: 'get_interface_strings',
                language: langCode,
                token: localStorage.getItem('token')
            });
        }

        // Function to apply interface strings to the page
        function applyInterfaceStrings(strings) {
            const currentStrings = strings || interfaceStrings[currentInterfaceLanguage] || interfaceStrings.en;
            
            // Update title
            document.title = `${currentStrings.appTitle} - Language Learning`;
            document.querySelector('#title p').textContent = currentStrings.appTitle;
            
            // Update login section
            document.querySelector('#init-login-section h3').textContent = currentStrings.pleaseLoginToStart;
            document.querySelector('#init-user-name').placeholder = currentStrings.email;
            document.querySelector('#init-user-password').placeholder = currentStrings.password;
            document.querySelector('#init-login-button').textContent = currentStrings.login;
            document.querySelector('#init-signup-button').textContent = currentStrings.signup;
            
            // Update main buttons
            document.querySelector('#initDailypages').textContent = currentStrings.dailyPages;
            document.querySelector('#initFreeRead').textContent = currentStrings.freeRead;
            
            // Update settings drawer
            document.querySelector('#settings-drawer h2').textContent = currentStrings.settings;
            document.querySelector('#user-name').placeholder = currentStrings.email;
            document.querySelector('#user-password').placeholder = currentStrings.password;
            document.querySelector('#login-button').textContent = currentStrings.login;
            document.querySelector('#signup-button').textContent = currentStrings.signup;
            document.querySelector('#userLanguages').textContent = currentStrings.nativeLanguage;
            document.querySelector('#tutorial').textContent = currentStrings.tutorial;
            document.querySelector('#found-bug').textContent = currentStrings.foundABug;
            document.querySelector('#tip-section h3').textContent = currentStrings.supportHablas;
            document.querySelector('#custom-tip').placeholder = currentStrings.customAmount;
            document.querySelector('#custom-tip-button').textContent = currentStrings.tip;
            
            // Update browse books button
            const browseBtn = document.querySelector('#browse-books-btn');
            if (browseBtn) {
                browseBtn.textContent = currentStrings.tapToBegin;
            }
            
            // Update pagele modals
            const pageleModalTitle = document.querySelector('#pagele-modal h2');
            if (pageleModalTitle) {
                pageleModalTitle.textContent = currentStrings.selectPagele;
            }
            
            const chaptersModalTitle = document.querySelector('#chapters-modal h2');
            if (chaptersModalTitle) {
                chaptersModalTitle.textContent = currentStrings.chapters;
            }
            
            const translateBtn = document.querySelector('#translation-btn');
            if (translateBtn) {
                translateBtn.textContent = currentStrings.translate;
            }
            
            const chapterTitle = document.querySelector('#chapter-title');
            if (chapterTitle && chapterTitle.textContent === 'Chapter Title') {
                chapterTitle.textContent = currentStrings.chapterTitle;
            }
            
            // Update points display
            const pointsDisplays = document.querySelectorAll('#points-display-pagele');
            pointsDisplays.forEach(el => {
                const currentText = el.textContent;
                if (currentText.startsWith('Points:')) {
                    el.textContent = `${currentStrings.points}: `;
                }
            });
            
            // Update mode switch button
            const modeText = document.querySelector('#mode-text');
            if (modeText) {
                if (currentMode === 'freeread') {
                    modeText.textContent = currentStrings.dailyPages;
                } else {
                    modeText.textContent = currentStrings.freeRead;
                }
            }
            
            // Update payment modal
            const paymentModalTitle = document.querySelector('#payment-modal h2');
            if (paymentModalTitle) {
                paymentModalTitle.textContent = currentStrings.completeYourTip;
            }
            
            const submitPaymentBtn = document.querySelector('#submit-payment');
            if (submitPaymentBtn) {
                submitPaymentBtn.textContent = currentStrings.payNow;
            }
            
            // Update user account options
            const userAccountTitle = document.querySelector('.user-account-options-modal-content p');
            if (userAccountTitle) {
                userAccountTitle.textContent = currentStrings.userAccountOptions;
            }
            
            const changeInfoBtn = document.querySelector('#change-info-button');
            if (changeInfoBtn) {
                changeInfoBtn.textContent = currentStrings.changeInfo;
            }
            
            const deleteAccountBtn = document.querySelector('#delete-account-button');
            if (deleteAccountBtn) {
                deleteAccountBtn.textContent = currentStrings.deleteAccount;
            }
            
            // Update status messages
            updateStatusMessages(currentStrings);
        }

        // Function to update status messages
        function updateStatusMessages(strings) {
            const statusMessages = document.querySelectorAll('.status-message');
            statusMessages.forEach(el => {
                if (el.textContent === 'Processing...') {
                    el.textContent = strings.processing;
                } else if (el.textContent === 'Fetching data...') {
                    el.textContent = strings.fetchingData;
                } else if (el.textContent === 'Parsing data...') {
                    el.textContent = strings.parsingData;
                }
            });
        }

        // Function to get current interface string
        function getInterfaceString(key) {
            const currentStrings = interfaceStrings[currentInterfaceLanguage] || interfaceStrings.en;
            return currentStrings[key] || interfaceStrings.en[key] || key;
        }

       

        const abbreviations = [
            'Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Prof.',
            'Sr.', 'Jr.', 'etc.', 'e.g.', 'i.e.', '."'
        ];

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const modalDiv = document.getElementById('myModal');
        const returnSentenceDiv = document.getElementById('return_sentence');
        const fileDiv = document.getElementById("file");
        const pointsDisplay = document.getElementById("points-display");
        const settingsBtn = document.getElementById("settings");
        const userSection = document.getElementById("user-section");
        const drawer = document.getElementById('settings-drawer');
        const closeDrawerBtn = document.getElementById('close-drawer');
        const availableBooksBtn = document.getElementById('available-books');
        const recordBtn = document.getElementById('record'); 
        const textToSpeechBtn = document.getElementById('robot');
        const translation = document.getElementById('translation');
        const languageDisplay2 = document.getElementById('userLanguages');
        const languageUserOptionsSelect = document.getElementById('languageUserOptions');
        const booksModal = document.getElementById('books-modal');
        const tutorialBtn = document.getElementById('tutorial');
        const usernameInput = document.getElementById('user-name');
        const passwordInput = document.getElementById('user-password');
        const loginButton = document.getElementById('login-button');
        const signupButton = document.getElementById('signup-button');
        const usernameInput2 = document.getElementById('init-user-name');   
        const passwordInput2 = document.getElementById('init-user-password');
        const loginButton2 = document.getElementById('init-login-button');
        const signupButton2 = document.getElementById('init-signup-button');
        const initDailypages = document.getElementById('initDailypages');
        const initFreeRead = document.getElementById("initFreeRead");
        const initChoice = document.getElementById('initChoice');
        const div2viewer = document.getElementById('div2viewer');

        // Pagele elements
        const pageleContent = document.getElementById('pagele-content');
        const sentenceModal = document.getElementById('sentence-modal');
        const pageleModal = document.getElementById('pagele-modal');
        const sentenceElem = document.getElementById('sentence-container');
        const counterElem = document.getElementById('sentence-counter');
        const prevButton = document.getElementById('prev-sentence');
        const nextButton = document.getElementById('next-sentence');
        const recordingStatusPagele = document.getElementById('recording-status-pagele');
        const prediction = document.getElementById('prediction-container');
        const pointsSpanPagele = document.getElementById('points-pagele');
        const availablePageleBtn = document.getElementById('available-pagele');
        const closeSentenceModalBtn = document.getElementById('close-sentence-modal');
        const chaptersModal = document.getElementById('chapters-modal');
        const recordBtnPagele = document.getElementById('record-pagele');
        const robotBtnPagele = document.getElementById('robot-pagele');
        const closeChaptersModal = document.getElementById('close-chapters-modal');
        const modeSwitch = document.getElementById('mode-switch');
        const modeText = document.getElementById('mode-text');
        const fetchingDataStatusElement = document.getElementById('fetching-data-status');

        // Initialize Stripe
        const stripe = Stripe('pk_live_51R936ZH6FESgUvUmI0Gu1qfxauHRtqnx9Usx1UkQQgzOVGC2e5MIhKopUsPcSw1n3XfUF8qZyuL7ZGb1wYUOR8DG007A0ipkpw');
        let elements;

        console.log("starting script");

        // WebSocket Connection
        function createWebSocketConnection() {
            const socket = new WebSocket('wss://carriertech.uk:8675');
            //const socket = new WebSocket('ws://localhost:8675');
            
            socket.addEventListener('open', (event) => {
                console.log('WebSocket connection established');
            });

            socket.addEventListener('error', (error) => {
                console.error('WebSocket error:', error);
            });

            socket.addEventListener('message', async (event) => {
                console.log("message received:", event);
                await handleWebSocketMessage(event);
            });

            socket.addEventListener('close', (event) => {
                console.log('WebSocket connection closed', event.code, event.reason);
            });

            return socket;
        }

        // Handle WebSocket messages
        async function handleWebSocketMessage(event) {
            const messageProcessingStartTime = performance.now();
 
            if (fetchingDataStatusElement) {
                fetchingDataStatusElement.style.display = 'flex';
            }

            console.log("Type of event.data: ", typeof event.data, "Is Blob?", event.data instanceof Blob, "Is ArrayBuffer?", event.data instanceof ArrayBuffer);
            
            let jsonString;
            let parsedResponseObject = null; 
            let conversionStartTime, conversionEndTime, parsingStartTime, parsingEndTime, afterConversionTime, afterParsingTime;

            // Handle different data types
            if (event.data instanceof ArrayBuffer) {
                console.log("Received ArrayBuffer, decoding...");
                try {
                    conversionStartTime = performance.now();
                    const decoder = new TextDecoder("utf-8");
                    jsonString = decoder.decode(event.data);
                    conversionEndTime = performance.now();
                    console.log(`ArrayBuffer decoding took ${(conversionEndTime - conversionStartTime).toFixed(2)} ms`);
                } catch (e) {
                    console.error("Error decoding ArrayBuffer:", e);
                    hideStatusIndicators();
                    return;
                }
            } else if (event.data instanceof Blob) {
                console.log("Received Blob, reading as text...");
                try {
                    conversionStartTime = performance.now();
                    jsonString = await event.data.text();
                    conversionEndTime = performance.now();
                    console.log(`Blob.text() took ${(conversionEndTime - conversionStartTime).toFixed(2)} ms`);
                } catch (e) {
                    console.error("Error reading Blob as text:", e);
                    hideStatusIndicators();
                    return;
                }
            } else if (typeof event.data === 'string') {
                console.log("Received string directly.");
                jsonString = event.data;
            } else {
                console.error("Received WebSocket message of unknown type:", event.data);
                hideStatusIndicators();
                return; 
            }

            afterConversionTime = performance.now();
            console.log(`Time from start to after data conversion: ${(afterConversionTime - messageProcessingStartTime).toFixed(2)} ms`);

            // Parse JSON
            if (typeof jsonString === 'string') {
                try {
                    parsingStartTime = performance.now();
                    parsedResponseObject = JSON.parse(jsonString);
                    parsingEndTime = performance.now();
                    console.log(`JSON.parse() took ${(parsingEndTime - parsingStartTime).toFixed(2)} ms`);
                } catch (e) {
                    console.error("Error parsing JSON string:", e);
                    console.error("Original string that failed parsing:", jsonString);
                    hideStatusIndicators();
                    return; 
                }
            } else {
                console.error("Could not convert event.data to a string for parsing.");
                hideStatusIndicators();
                return;
            }
            
            afterParsingTime = performance.now();
            console.log(`Time from start to after JSON parsing: ${(afterParsingTime - messageProcessingStartTime).toFixed(2)} ms`);

            const response = parsedResponseObject; 
            
            // Hide status indicators
            if (fetchingDataStatusElement) { 
                fetchingDataStatusElement.style.display = 'none';
            }
            
            const messageOverallEndTime = performance.now();
            console.log(`Overall message parsing took ${(messageOverallEndTime - messageProcessingStartTime).toFixed(2)} ms`);

            console.log("Received WebSocket message (parsed successfully):", response);
            
            // Handle different response types
            await handleResponse(response);
        }

        // Helper function to hide status indicators
        function hideStatusIndicators() {
            const statusIndicator = document.getElementById('recording-status');
            const statusIndicatorPagele = document.getElementById('recording-status-pagele');
            const fetchingDataStatusElement = document.getElementById('fetching-data-status');
            
            if (statusIndicator && statusIndicator.style.display !== 'none') {
                clearInterval(timerInterval);
                statusIndicator.style.display = 'none';
                if (processingStartTime) processingStartTime = 0;
            }
            if (statusIndicatorPagele && statusIndicatorPagele.style.display !== 'none') {
                clearInterval(timerInterval);
                statusIndicatorPagele.style.display = 'none';
                if (processingStartTime) processingStartTime = 0;
            }
            if (fetchingDataStatusElement) fetchingDataStatusElement.style.display = 'none';
        }

        // Handle different response types
        async function handleResponse(response) {
            // Hide recording status indicators when response received
            hideStatusIndicators();

            if (!response) {
                console.error("Response is null, cannot proceed with message handling.");
                return;
            }

            // Handle array response (direct pagele list)
            if (Array.isArray(response)) {
                console.log('Received pagele list array directly');
                displayPageleList(response);
            }
            // Handle authentication success
            else if (response.status === "success" && response.hasOwnProperty('username')) {
                handleAuthSuccess(response);
            } 
            // Handle token verification
            else if (response.type === 'token_verification_result') {
                handleTokenVerification(response);
            }
            // Handle books response
            else if (response.hasOwnProperty('books')) {
                handleBooksResponse(response);
            }
            // Handle prediction sentence
            else if (response.hasOwnProperty('pred_sentence')) {
                handlePredSentence(response);
            }
            // Handle translation
            else if (response.hasOwnProperty('translation') || 
                    (response.status === 'success' && response.hasOwnProperty('translated_text'))) {
                handleTranslationResponse(response);
            }
            // Handle translated words (pagele)
            else if (response.hasOwnProperty('translated_words')) {
                handleTranslatedWords(response);
            }
            // Handle token response
            else if (response.hasOwnProperty('token')) {
                handleTokenResponse(response);
            }
            // Handle book data
            else if (response.status === 'success' && response.hasOwnProperty('epub')) {
                handleBookDataResponse(response);
            }
            // Handle TTS response
            else if (response.status === 'success' && response.hasOwnProperty('audio')) {
                handleTTSResponse(response);
            }
            // Handle pagele list
            else if (response.type === 'pagele_list') {
                displayPageleList(response.pagele_books);
            }
            // Handle get pagele
            else if (response.type === 'get_pagele') {
                displayChaptersGrid(response);
            }
            // Handle payment
            else if (response.status === 'success' && response.client_secret) {
                handlePaymentResponse(response);
            }
            // Handle invalid credentials
            else if (response.message === "Invalid credentials") {
                alert(getInterfaceString('invalidCredentials'));
            }
            // Handle book filename response
            else if (response.hasOwnProperty('filename')) {
                handleBookFilenameResponse(response);
            }
            // Handle interface strings response
            else if (response.type === 'interface_strings') {
                handleInterfaceStringsResponse(response);
            }
            // Handle bug report response
            else if (response.type === 'bug_report_sent') {
                console.log('Bug report sent successfully');
            }
            // Handle preferred language
            else if (response && response.preferred_language && typeof response.preferred_language === 'string') {
                userInfo.preferredLanguage = response.preferred_language;
                console.log("Found preferred language in response:", response.preferred_language);
                
                const languageSelect = document.getElementById('languageUserOptions');
                if (languageSelect) {
                    languageSelect.value = response.preferred_language;
                }
            }
            else {
                console.log("Unhandled response from server:", response);
            }
        }

        // Initialize the socket
        let socket = createWebSocketConnection();

        // Function to send a message through the socket
        function sendSocketMessage(message) {
            if (socket.readyState !== WebSocket.OPEN) {
                console.log('Socket not open, creating new connection');
                socket = createWebSocketConnection();
                
                socket.addEventListener('open', () => {
                    socket.send(JSON.stringify(message));
                }, { once: true });
            } else {
                socket.send(JSON.stringify(message));
            }
            if (fetchingDataStatusElement) {
                fetchingDataStatusElement.style.display = 'flex';
            }
        }

        // Mode switching functions
        function switchToMode(mode) {
            // Hide all mode containers
            document.getElementById('initChoice').style.display = 'none';
            document.getElementById('div2viewer').style.display = 'none';
            document.getElementById('pagele-content').style.display = 'none';
            
            // Show selected mode
            switch(mode) {
                case 'init':
                    document.getElementById('initChoice').style.display = 'flex';
                    currentMode = 'init';
                    break;
                case 'freeread':
                    document.getElementById('div2viewer').style.display = 'flex';
                    currentMode = 'freeread';
                    modeText.textContent = 'Daily Pages';
                    break;
                case 'pagele':
                    document.getElementById('pagele-content').style.display = 'block';
                    currentMode = 'pagele';
                    modeText.textContent = 'Free Read';
                    // Show pagele modal if not already visible
                    if (pageleModal.style.display !== 'block' && 
                        sentenceModal.style.display !== 'block' && 
                        chaptersModal.style.display !== 'block') {
                        requestPageleList();
                    }
                    break;
            }
        }

        // Response handlers
        function handleAuthSuccess(response) {
            console.log("Auth success:", response);
            logEvent('User authentication successful', { username: response.username });
            
            if (response.token) {
                localStorage.setItem('token', response.token);
            }
            
            if (response.username) {
                localStorage.setItem('username', response.username);
                userInfo.username = response.username;
            }
            
            isLoggedIn = true;
            
            if (response.points) {
                userInfo.points = response.points;
            }
            
            if (response.preferred_language) {
                userInfo.preferredLanguage = response.preferred_language;
                console.log("Stored preferred language from auth:", response.preferred_language);
                
                const languageSelect = document.getElementById('languageUserOptions');
                if (languageSelect) {
                    languageSelect.value = response.preferred_language;
                }
            }
            
            updateAuthUI(true, response);
            drawer.classList.remove('open');
        }

        function handleTokenVerification(response) {
            if (response.success) {
                console.log('Token verification successful');
                isLoggedIn = true;
                
                if (response.user_data && response.user_data.username) {
                    userInfo.username = response.user_data.username;
                    if (response.user_data.points) {
                        userInfo.points = response.user_data.points;
                    }
                    
                    if (response.user_data.preferred_language) {
                        userInfo.preferredLanguage = response.user_data.preferred_language;
                    }
                }
                
                updateAuthUI(true, response);
                
                if (!response.user_data.selected_pagele) {
                    // User can choose mode
                }
            } else {
                console.log('Token verification failed');
                localStorage.removeItem('token');
                localStorage.removeItem('username');
                handleInvalidToken();
            }
        }

        function handleInvalidToken() {
            isLoggedIn = false;
            updateAuthUI(false);
            alert(getInterfaceString('sessionExpired'));
            switchToMode('init');
        }

        function updateAuthUI(isLoggedIn, responseData = null) {
            const loginSignupContainer = document.getElementById('login-singup');
            const usernameInput = document.getElementById('user-name');
            const passwordInput = document.getElementById('user-password');
            const initLoginSection = document.getElementById('init-login-section');
            
            if (isLoggedIn) {
                // Hide login/signup elements in settings drawer
                loginSignupContainer.style.display = 'none';
                usernameInput.style.display = 'none';
                passwordInput.style.display = 'none';
                
                // Hide login section on initial screen
                if (initLoginSection) {
                    initLoginSection.style.display = 'none';
                }
                
                // Enable buttons
                initDailypages.classList.remove('disabled');
                initFreeRead.classList.remove('disabled');
                
                if (responseData && responseData.language) {
                    sourceLang = responseData.language;
                    languageSel = setLanguage(sourceLang);
                }
                
                // Add logged-in user display to settings
                const userInfoDiv = document.createElement('div');
                userInfoDiv.id = 'user-info';
                userInfoDiv.className = 'options';
                userSection.textContent = userInfo.username;
                userInfoDiv.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <span>${getInterfaceString('loggedInAs')}: ${userInfo.username}</span>
                        <button id="logout-button" class="small-button">${getInterfaceString('logout')}</button>
                    </div>
                `;
                
                const settingsOptions = document.getElementById('settings-options');
                settingsOptions.insertBefore(userInfoDiv, document.getElementById('available-books'));
                
                document.getElementById('logout-button').addEventListener(EVENT_TYPE, handleLogout);

                // Load user's current book if available in responseData
                if (responseData && responseData.current_book && responseData.epub) {
                    selectedBook = responseData.current_book;
                    console.log("selectedBook: ", selectedBook);
                    selectedPage = responseData.page || 0;
                    language = responseData.language;
                    languageSel = setLanguage(language);
                    console.log("Loading user's current book:", selectedBook);
                    
                    const base64Data = responseData.epub.split(',')[1];
                    const mimeString = responseData.epub.split(',')[0].split(':')[1].split(';')[0];
                    const byteString = atob(base64Data);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    const blob = new Blob([ab], {type: mimeString});
                    cfi = responseData.cfi;
                    
                    renderEpub(blob, responseData.cfi).then(() => {
                        if (selectedPage && rendition) {
                            rendition.display(selectedPage);
                        }
                    }).catch(error => {
                        console.error('Error rendering book:', error);
                    });
                }
            } else {
                // Show login/signup elements in settings drawer
                loginSignupContainer.style.display = 'flex';
                usernameInput.style.display = 'block';
                passwordInput.style.display = 'block';
                
                // Show login section on initial screen
                if (initLoginSection) {
                    initLoginSection.style.display = 'block';
                }
                
                // Disable buttons
                initDailypages.classList.add('disabled');
                initFreeRead.classList.add('disabled');
                
                // Remove user info if it exists
                const userInfo = document.getElementById('user-info');
                if (userInfo) {
                    userInfo.remove();
                }
            }
        }

        function handleLogout() {
            logEvent('User logged out');
            localStorage.removeItem('token');
            localStorage.removeItem('username');
            userSection.innerHTML = "Login";
            updateAuthUI(false);
            
            username = '';
            password = '';
            drawer.classList.remove('open');
            
            switchToMode('init');
            
            sendSocketMessage({
                task: "logout",
                username: username
            });
        }

        function handleBooksResponse(response) {
            const booksByLanguage = response.books.reduce((acc, book) => {
                if (!acc[book.language]) {
                    acc[book.language] = [];
                }
                acc[book.language].push(book);
                return acc;
            }, {});
            
            const booksGrid = document.getElementById('books-grid');
            booksGrid.innerHTML = '';
            
            Object.entries(booksByLanguage).forEach(([language, languageBooks]) => {
                const languageSection = document.createElement('div');
                languageSection.className = 'language-section';
                
                const languageHeader = document.createElement('h2');
                languageHeader.textContent = language.charAt(0).toUpperCase() + language.slice(1);
                languageSection.appendChild(languageHeader);
                
                const booksContainer = document.createElement('div');
                booksContainer.className = 'books-container';
                
                languageBooks.forEach(book => {
                    const bookElement = document.createElement('div');
                    bookElement.className = 'book';

                    const img = document.createElement('img');
                    if (book.cover && book.cover.startsWith('data:')) {
                        img.src = book.cover;
                    } else {
                        img.src = 'images/default-cover.png';
                        console.error('Invalid cover data for book:', book.filename);
                    }
                    img.alt = book.filename;
                
                    const title = document.createElement('div');
                    title.className = 'book-title';
                    title.textContent = book.filename.replace('.epub', '');
                    
                    bookElement.appendChild(img);
                    bookElement.appendChild(title);
                    
                    // Use touch-aware event listener for book selection
                    const addBookEventListener = createTouchAwareEventListener(async (e) => {
                        title.textContent = "Loading...";
                        
                        sendSocketMessage({
                            task: "get_book_data",
                            filename: book.filename,
                        });
                    });
                    addBookEventListener(bookElement);
                    
                    booksContainer.appendChild(bookElement);
                });
                
                languageSection.appendChild(booksContainer);
                booksGrid.appendChild(languageSection);
            });
        }

        function handlePredSentence(response) {
            console.log("handlePredSentence: ", response);
            const predSentence = response.pred_sentence;
            console.log("predSentence: ", predSentence);
            
            if (currentMode === 'freeread') {
                returnSentenceDiv.innerHTML = predSentence;
                
                document.querySelectorAll('.wrong').forEach(wrongWord => {
                    wrongWord.addEventListener(EVENT_TYPE, (event) => {
                        document.querySelectorAll('.wrong').forEach(w => w.classList.remove('pressed'));
                        wrongWord.classList.add('pressed');
                        
                        const correctWord = wrongWord.id;
                        console.log("Correct word:", correctWord);
                        
                        if (correctWord && !popupflag) {
                            createPopup(correctWord, event);
                        }
                    });
                });
                
                const pointsDisplay = document.getElementById('points-display');
                pointsDisplay.style.display = 'block';
                
                const wrongElements = document.getElementsByClassName("wrong");
                const correctWords = response.points;
                
                const pointsEarned = correctWords * 10;
                userPoints += pointsEarned;
                updatePointsDisplay(userPoints);
            } else if (currentMode === 'pagele') {
                console.log("Received prediction for pagele:", response);
                
                prediction.innerHTML = predSentence;
                
                document.querySelectorAll('.wrong').forEach(wrongWord => {
                    wrongWord.addEventListener('click', (event) => {
                        const correctWord = wrongWord.id;
                        if (correctWord) {
                            textToSpeech(correctWord);
                        }
                    });
                });
                
                pointsSpanPagele.innerHTML = response.points;
                completedIndices[currentChapter][currentSentenceIndex] = response.points;
            }
        }

        function handleTranslationResponse(response) {
            const translatedText = response.translated_text || response.translation;
            translation.innerHTML = translatedText;
            console.log("Updated translation with:", translatedText);
        }

        function handleTranslatedWords(response) {
            console.log("translated_text: ", response.translated_words);
            if (translate_down) {
                sentenceElem.innerHTML = response.translated_words;
            }
            translated_text = response.translated_words;
            translation.innerHTML = translated_text;
        }

        function handleTokenResponse(response) {
            console.log("Token response:", response);
            localStorage.setItem('token', response.token);
            username = response.username;
            console.log("username: ", username);
            
            if (response.language) {
                sourceLang = response.language;
                if (languageSel) {
                    languageSel = setLanguage(sourceLang);
                }
            }
            
            updateAuthUI(true, response);
            drawer.classList.remove('open');
        }

        function handleBookDataResponse(response) {
            console.log("response:", response);
            
            selectedBook = response.filename;
            console.log("Set selectedBook:", selectedBook);

            sourceLang = response.language;
            languageSel = setLanguage(sourceLang);
            console.log("epub:", response.epub);
            
            const base64Data = response.epub.split(',')[1];
            console.log("Base64 data:", base64Data);
            
            if (!base64Data) {
                throw new Error('Invalid EPUB data format');
            }

            const mimeString = response.epub.split(',')[0].split(':')[1].split(';')[0];
            const byteString = atob(base64Data);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            
            renderEpub(blob).then(() => {
                if (response.page) {
                    rendition.display(response.page);
                }
                if (booksModal) {
                    booksModal.style.display = 'none';
                }
            }).catch(error => {
                console.error('Error rendering book:', error);
                alert('Error rendering book: ' + error.message);
            });
        }

        function handleTTSResponse(response) {
            console.log("Received TTS response:", response);
            
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            
            const audio = new Audio(response.audio);
            currentAudio = audio;
            
            // Determine which robot button to update based on current mode
            let robotBtn;
            if (currentMode === 'freeread') {
                robotBtn = document.getElementById('robot');
            } else if (currentMode === 'pagele') {
                robotBtn = document.getElementById('robot-pagele');
            }
            
            if (robotBtn) {
                robotBtn.setAttribute('data-speaking', 'true');
                robotBtn.style.filter = 'brightness(0.7)';
            }
            
            audio.onended = () => {
                console.log('Speech ended');
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
            
            audio.onerror = (e) => {
                console.error('Speech error:', e);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
            
            audio.play();
        }

        function handlePaymentResponse(response) {
            elements = stripe.elements({
                clientSecret: response.client_secret,
                appearance: {
                    theme: 'stripe',
                    variables: {
                        colorPrimary: '#0570de',
                        colorBackground: '#ffffff',
                        colorText: '#30313d',
                    }
                }
            });

            const paymentElement = elements.create('payment');
            paymentElement.mount('#payment-element');

            document.getElementById('submit-payment').addEventListener(EVENT_TYPE, async (e) => {
                e.preventDefault();
                
                const { error, paymentIntent } = await stripe.confirmPayment({
                    elements,
                    confirmParams: {
                        return_url: window.location.origin
                    },
                    redirect: 'if_required'
                });

                if (error) {
                    const messageDiv = document.getElementById('payment-message');
                    messageDiv.textContent = error.message;
                    console.error('Payment error:', error);
                } else if (paymentIntent && paymentIntent.status === 'succeeded') {
                    document.getElementById('payment-modal').style.display = 'none';
                    alert(getInterfaceString('thankYouForTip'));
                } else if (paymentIntent && paymentIntent.status === 'requires_action') {
                   const messageDiv = document.getElementById('payment-message');
                    messageDiv.textContent = 'Further action is required to complete your payment. Please follow the prompts from your bank.';
                } else {
                    const messageDiv = document.getElementById('payment-message');
                    messageDiv.textContent = 'Payment processing. You will be redirected if necessary.';
                }
            });
        }

        function handleBookFilenameResponse(response) {
            const epubData = response.epub;
            const base64Data = epubData.split(',')[1];
            if (!base64Data) {
                throw new Error('Invalid EPUB data format');
            }
            
            const byteString = atob(base64Data);
            const mimeString = epubData.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            const blob = new Blob([ab], {type: mimeString});
            renderEpub(blob);
            booksModal.style.display = 'none';
            
            languageSel = setLanguage(language);
            selectedBook = response.filename;
            console.log("selected ", selectedBook);
        }

        function handleInterfaceStringsResponse(response) {
            console.log("Received interface strings:", response);
            if (response.language && response.strings) {
                interfaceStrings[response.language] = response.strings;
                if (response.language === currentInterfaceLanguage) {
                    applyInterfaceStrings(response.strings);
                }
            }
        }

        // Utility functions
        function setLanguage(language) {
            if (lang_conversion[language]) {
                return lang_conversion[language];
            } else {
                return language;
            }
        }

        function loadAvailableBooks() {
            sendSocketMessage({ task: 'get_books' });
            booksModal.style.display = 'block';
        }

        function verifyToken(token) {
            sendSocketMessage({
                task: "verify_token",
                token: token
            });
        }

        async function updateTranslation(text) {
            console.log(`Translating text: "${text}" from ${sourceLang}`);
            
            translation.textContent = "Translating...";
            
            const targetLang = languageUserOptionsSelect.value;
            console.log("targetLang: ", targetLang);
            console.log("sourceLang: ", sourceLang);
            console.log("username: ", username);
            
            if (rendition) {
                const contents = rendition.getContents();
                cfi = rendition.currentLocation().start.cfi;
                console.log("cfi: ", cfi);
            }
            
            sendSocketMessage({ 
                task: 'translate', 
                text: text, 
                source_lang: sourceLang, 
                target_lang: targetLang, 
                current_book: selectedBook, 
                cfi: cfi,
                username: username 
            });
        }

        function createBlobAndConnect() {
            const statusIndicator = currentMode === 'freeread' ? 
                document.getElementById('recording-status') : 
                document.getElementById('recording-status-pagele');
                
            if (statusIndicator) {
                statusIndicator.style.display = 'flex';
                processingStartTime = Date.now();
                updateTimer();
                timerInterval = setInterval(updateTimer, 100);
            }

            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            audioChunks = [];

            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = function() {
                const base64data = reader.result;
                
                console.log("Current language value:", languageSel);
                console.log("Current sourceLang:", sourceLang);
                
                if (currentMode === 'freeread') {
                    sendSocketMessage({ 
                        task: 'stt', 
                        blob: base64data, 
                        language: languageSel, 
                        sentence: lines[lineNum], 
                        username: username, 
                        book: selectedBook, 
                        page: selectedPage 
                    });
                } else if (currentMode === 'pagele') {
                    const currentSentence = sentenceElem.textContent;
                    let language = pagele_language;
                    if (language.length == 2) {
                        language = lang_conversion[language];
                    }
                    sendSocketMessage({ 
                        task: 'stt', 
                        blob: base64data, 
                        language: language, 
                        sentence: currentSentence,
                        username: localStorage.getItem('username') || '',
                        book: pageleFilename, 
                        chapter: currentChapter,
                        currentSentenceIndex: currentSentenceIndex,
                        page: 'pagele'
                    });
                }
            };
        }

        // Free reading functions
        async function renderEpub(file, cfi = null) {
            currentBook = ePub(file);
            const viewer = document.getElementById("viewer");
            viewer.innerHTML = "";
                    rendition = currentBook.renderTo("viewer", {
            height: "100%",
            width: "100%",
            allowScriptedContent: false,
            flow: "scrolled-doc",
            manager: "continuous"
        });
            
            console.log("cfi: ", cfi);
            if (cfi) {
                rendition.display(cfi, { offsetTop: 1000 });
            } else {
                rendition.display().then(() => {
                    addClickHandlersToPage();
                });
            }
            
            rendition.on("rendered", (section) => {
                selectedPage = section.href;
                addClickHandlersToPage();
                const contents = rendition.getContents();
            });
            
            function addClickHandlersToPage() {
                const contents = rendition.getContents();
                
                contents.forEach(content => {
                    const style = content.document.createElement('style');
                    style.textContent = `
                        @keyframes pulse {
                            0% { background-color: transparent; }
                            50% { background-color: rgba(169, 209, 215, 0.3); }
                            100% { background-color: transparent; }
                        }
                        .pulse-animation {
                            animation: pulse 2s infinite;
                        }
                        .sentence-icon {
                            font-size: 16px;
                            margin-right: 4px;
                            vertical-align: middle;
                            display: inline-block;
                        }
                        .pulse-animation .sentence-icon {
                            opacity: 1 !important;
                        }
                    `;
                    content.document.head.appendChild(style);
                    
                    content.document.querySelectorAll('.pulse-animation').forEach(el => {
                        el.classList.remove('pulse-animation');
                        const icon = el.querySelector('.sentence-icon');
                        if (icon) {
                            icon.remove();
                        }
                    });

                    let isFirstSentence = true;
                    
                    content.document.querySelectorAll('p, span').forEach((element, elementIndex) => {
                        if (element.dataset.processed === "true") return;
                        
                        if (element.textContent.trim() === element.textContent.trim().toUpperCase()) {
                            element.dataset.processed = "true";
                            return;
                        }
                        
                        const sentences = element.textContent.split(/(?<=[.!?])\s+/);
                        if (sentences.length === 0) return;
                        
                        element.textContent = '';
                        element.dataset.processed = "true";
                        
                        sentences.forEach((sentence, index) => {
                            if (sentence.trim().length < 2) return;
                            
                            const sentenceSpan = content.document.createElement('span');
                            sentenceSpan.textContent = sentence + ' ';
                            sentenceSpan.style.cursor = 'pointer';
                            sentenceSpan.style.borderRadius = '3px';
                            sentenceSpan.style.transition = 'background-color 0.2s ease';
                            
                            if (isFirstSentence && 
                                sentence.trim() !== sentence.trim().toUpperCase() && 
                                sentence.trim().length > 10) {
                                const selectIcon = content.document.createElement('span');
                                selectIcon.className = 'sentence-icon';
                                selectIcon.style.opacity = '1';
                                sentenceSpan.insertBefore(selectIcon, sentenceSpan.firstChild);
                                sentenceSpan.classList.add('pulse-animation');
                                isFirstSentence = false;
                            }
                            
                            sentenceSpan.addEventListener('mouseover', () => {
                                sentenceSpan.style.backgroundColor = 'rgba(169, 209, 215, 0.3)';
                            });
                            
                            sentenceSpan.addEventListener('mouseout', () => {
                                if (!sentenceSpan.classList.contains('selected-line')) {
                                    sentenceSpan.style.backgroundColor = 'transparent';
                                }
                            });
                            
                            sentenceSpan.addEventListener(EVENT_TYPE, (event) => {
                                content.document.querySelectorAll('.pulse-animation').forEach(el => {
                                    el.classList.remove('pulse-animation');
                                    const icon = el.querySelector('.sentence-icon');
                                    if (icon) {
                                        icon.remove();
                                    }
                                });
                                
                                content.document.querySelectorAll('.selected-line').forEach(el => {
                                    el.classList.remove('selected-line');
                                    el.style.backgroundColor = 'transparent';
                                });
                                
                                sentenceSpan.classList.add('selected-line');
                                sentenceSpan.style.backgroundColor = 'rgba(169, 209, 215, 0.5)';
                                
                                const modalContent = modalDiv.querySelector('.modal-content');
                                
                                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                                
                                if (isMobile) {
                                    modalContent.style.width = `calc(100vw - 20px)`;
                                    modalContent.style.maxWidth = '100%';
                                } else {
                                    const modalWidth = Math.min(window.innerWidth - 40, 800);
                                    modalContent.style.width = `${modalWidth}px`;
                                }
                                
                                modalDiv.style.display = 'block';
                                
                                selectedText = sentence.trim();
                                lines = [selectedText];
                                lineNum = 0;
                                updateTranslation(selectedText);
                                
                                event.stopPropagation();
                            });
                            
                            element.appendChild(sentenceSpan);
                        });
                    });
                });
            }
            
            fileDiv.style.display = "none";
            
            if (!document.getElementById('scroll-down-btn')) {
                const scrollBtn = document.createElement('button');
                scrollBtn.id = 'scroll-down-btn';
                scrollBtn.textContent = 'Load More';
                scrollBtn.style.position = 'absolute';
                scrollBtn.style.bottom = '10px';
                scrollBtn.style.left = '50%';
                scrollBtn.style.transform = 'translateX(-50%)';
                scrollBtn.style.zIndex = '100';
                scrollBtn.style.padding = '10px 20px';
                scrollBtn.style.backgroundColor = '#007bff';
                scrollBtn.style.color = 'white';
                scrollBtn.style.border = 'none';
                scrollBtn.style.borderRadius = '5px';
                scrollBtn.style.cursor = 'pointer';
                scrollBtn.style.marginBottom = '10px';
                
                let currentSpinePosition = 0;
                
                scrollBtn.onclick = async () => {
                    try {
                        const currentLocation = rendition.currentLocation();
                        if (!currentLocation) {
                            console.log("No current location found");
                            return;
                        }
                        
                        const spine = currentBook.spine;
                        if (!spine) {
                            console.log("No spine found");
                            return;
                        }
                        
                        currentSpinePosition++;
                        if (currentSpinePosition >= spine.length) {
                            console.log("Reached end of book");
                            scrollBtn.style.display = 'none';
                            return;
                        }
                        
                        console.log(`Moving to spine position ${currentSpinePosition}`);
                        
                        await rendition.display(spine.get(currentSpinePosition).href);
                        addClickHandlersToPage();
                        
                        console.log("Moved to next section");
                        scrollBtn.style.display = 'none';
                    } catch (error) {
                        console.error("Error navigating:", error);
                    }
                };
                
                const div2viewer = document.getElementById('div2viewer');
                div2viewer.appendChild(scrollBtn);
                div2viewer.style.position = 'relative';
            }
            
            if (cfi) {
                rendition.display(cfi, { offsetTop: 1000 });
            }
        }

        function textToSpeech(textToSpeak) {
            console.log('Starting text-to-speech for:', textToSpeak);
            
            
            const ttsLang = languageSel.substring(0,2);
            console.log('Using language:', ttsLang);
            
            textToSpeechBtn.setAttribute('data-speaking', 'true');
            textToSpeechBtn.style.filter = 'brightness(0.7)';
            
            sendSocketMessage({
                task: 'tts',
                text: textToSpeak,
                language: ttsLang
            });
        }

        function createPopup(content, event) {
            document.querySelectorAll('.popup').forEach(popup => popup.remove());
            
            const popup = document.createElement('div');
            const closePopupButton = document.createElement('span');
            const contentElement = document.createElement('p');
            
            closePopupButton.innerHTML = '&times;';
            closePopupButton.style.position = 'absolute';
            closePopupButton.style.top = '5px';
            closePopupButton.style.right = '10px';
            closePopupButton.style.cursor = 'pointer';
            closePopupButton.style.fontSize = '18px';
            closePopupButton.style.fontWeight = 'bold';
            closePopupButton.classList.add('popup-close');
            
            contentElement.textContent = content;
            
            popup.appendChild(contentElement);
            popup.appendChild(closePopupButton);
            
            closePopupButton.addEventListener(EVENT_TYPE, (e) => {
                popup.remove();
                popupflag = false;
                e.stopPropagation();
            });
            
            popup.addEventListener(EVENT_TYPE, (e) => {
                popup.remove();
                popupflag = false;
                e.stopPropagation();
            });
            
            const x = event.clientX || (event.touches && event.touches[0].clientX) || 0;
            const y = event.clientY || (event.touches && event.touches[0].clientY) || 0;
            
            popup.style.position = 'absolute'; 
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`; 
            popup.classList.add('popup');
            
            document.body.appendChild(popup);
            popup.style.zIndex = 1000;
            
            if (content) {
                console.log("Speaking correct word:", content);
                textToSpeech(content);
            } else {
                console.error("No content to speak");
            }
            
            popupflag = true;
        }

        function updatePointsDisplay(points) {
            const pointsDisplays = document.querySelectorAll('#points');
            pointsDisplays.forEach(element => {
                element.textContent = points;
            });

            const pointsDisplayDivs = document.querySelectorAll('#points-display');
            pointsDisplayDivs.forEach(div => {
                div.style.display = 'block';
                div.style.textAlign = 'center';
                div.style.fontSize = '1em';
                div.style.fontWeight = 'bold';
            });
        }

        function updateTimer() {
            const timerElement = currentMode === 'freeread' ? 
                document.querySelector('#recording-status .timer') : 
                document.querySelector('#recording-status-pagele .timer');
                
            if (timerElement && processingStartTime) {
                const elapsedTime = (Date.now() - processingStartTime) / 1000;
                timerElement.textContent = `${elapsedTime.toFixed(1)}s`;
            }
        }

        function isValidEmail(email) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            console.log("email:", emailRegex);
            return emailRegex.test(email);
        }

        // Pagele-specific functions
        function requestPageleList() {
            sendSocketMessage({
                task: "get_pagele_list",
                token: localStorage.getItem('token')
            });
        }

        function displayPageleList(pageleBooks) {
            const pageleList = document.getElementById('pagele-list');
            pageleList.innerHTML = '';
            
            if (pageleBooks.length === 0) {
                pageleList.innerHTML = `<p>${getInterfaceString('noPageleBooksAvailable')}</p>`;
            } else {
                pageleBooks.forEach(pagele => {
                    const card = document.createElement('div');
                    card.className = 'pagele-card';
                    card.dataset.pageleId = pagele.filename;
                    
                    card.innerHTML = `
                        <img class="pagele-cover" src="${pagele.cover}" alt="${pagele.book_name} cover">
                        <div class="pagele-title">${pagele.book_name}</div>
                        <div class="pagele-language">${pagele.language}</div>
                    `;
                    
                    // Use touch-aware event listener for pagele selection
                    const addPageleEventListener = createTouchAwareEventListener((e) => {
                        selectPagele(pagele.filename, pagele.language, 0);
                    });
                    addPageleEventListener(card);
                    pageleList.appendChild(card);
                });
            }
            
            showPageleModal();
        }

        function showPageleModal() {
            pageleModal.style.display = 'block';
            sentenceModal.style.display = 'none';
        }

        function hidePageleModal() {
            pageleModal.style.display = 'none';
        }

        function selectPagele(pageleFilename, language, index) {
            pagele_language = language;
            languageSel = setLanguage(language);
            console.log("languageSel: ", languageSel);
            sendSocketMessage({
                task: "init_pagele",
                pagele_filename: pageleFilename,
                language: language,
                index: index,
                token: localStorage.getItem('token')
            });
            console.log("Selected pagele:", pageleFilename);
            hidePageleModal();
        }

        function displayChaptersGrid(response) {
            pageleFilename = response.user_pagele.current_pagele;
            completedIndices = response.user_pagele.books[pageleFilename].completed_indices;
            console.log("completedIndices: ", completedIndices);
            
            const chaptersGrid = document.getElementById('chapters-grid');
            chaptersGrid.innerHTML = '';
            pagele_data = response.pagele_data;
            
            if (Object.keys(pagele_data).length === 0) {
                chaptersGrid.innerHTML = `<p>${getInterfaceString('noChaptersAvailable')}</p>`;
            } else {
                Object.keys(pagele_data).forEach((chapter, index) => {
                    const card = document.createElement('div');
                    card.className = 'chapter-card';
                    card.dataset.chapterIndex = index;   
                    
                    card.innerHTML = `
                        <div class="chapter-title">${chapter}</div>
                    `;
                    
                    // Use touch-aware event listener for chapter selection
                    const addChapterEventListener = createTouchAwareEventListener((e) => {
                        openSentenceModal(chapter, index, completedIndices[chapter]);
                    });
                    addChapterEventListener(card);
                    chaptersGrid.appendChild(card);
                });
            }
            
            showChaptersModal();
        }

        function showChaptersModal() {
            chaptersModal.style.display = 'block';
        }

        function hideChaptersModal() {
            chaptersModal.style.display = 'none';
        }

        function openSentenceModal(chapter, chapterIndex, chapterPoints) {
            currentChapter = chapter;
            hideChaptersModal();

            currentSentenceIndex = 0;
            console.log("currentChapter: ", chapter);
            document.getElementById('chapter-title').textContent = chapter;
            
            updateSentenceDisplay();
            
            sentenceModal.style.display = 'block';
        }

        function updateSentenceDisplay() {
            let sentences = pagele_data[currentChapter];
            if (sentences.length === 0) {
                sentenceElem.textContent = getInterfaceString('noSentencesAvailable');
                counterElem.textContent = "0/0";
                prevButton.disabled = true;
                nextButton.disabled = true;
                return;
            }
            
            sentenceElem.textContent = sentences[currentSentenceIndex];
            counterElem.textContent = `${currentSentenceIndex + 1}/${sentences.length}`;
            
            let sentencePoints = 0;
            console.log("completedIndices: ", completedIndices);
            console.log("currentChapter: ", completedIndices[currentChapter]);
            console.log("currentSentenceIndex: ", completedIndices[currentChapter][currentSentenceIndex]);
            
            if (completedIndices && 
                completedIndices[currentChapter] && 
                completedIndices[currentChapter][currentSentenceIndex] !== undefined) {
                sentencePoints = completedIndices[currentChapter][currentSentenceIndex];
                console.log("sentencePoints: ", sentencePoints);
            }
            
            if (pointsSpanPagele) {
                pointsSpanPagele.textContent = sentencePoints;
                console.log("pointsSpan updated with: ", sentencePoints);
            } else {
                console.error("Points span element not found!");
            }
            
            if (sentencePoints > 0) {
                sentenceElem.classList.add('completed');
                if (sentencePoints >= 10) {
                    sentenceElem.classList.add('max-points');
                } else {
                    sentenceElem.classList.remove('max-points');
                }
            } else {
                sentenceElem.classList.remove('completed', 'max-points');
            }
            
            prevButton.disabled = currentSentenceIndex === 0;
            nextButton.disabled = currentSentenceIndex === sentences.length - 1;
        }

        function showPreviousSentence() {
            translated_text = "";
            prediction.innerHTML = "";
            if (currentSentenceIndex > 0) {
                currentSentenceIndex--;
                updateSentenceDisplay();
            }
        }

        function showNextSentence() {
            translated_text = "";
            prediction.innerHTML = "";
            if (currentSentenceIndex < pagele_data[currentChapter].length - 1) {
                currentSentenceIndex++;
                console.log("currentSentenceIndex: ", currentSentenceIndex);
                updateSentenceDisplay();
            }
        }

        function closeSentenceModal() {
            sentenceModal.style.display = 'none';
            showChaptersModal();
        }

        
        function playAudioFromData(audioData, textKeyForLog) {
            console.log(`Playing audio for: ${textKeyForLog}`);
        
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
        
            const audio = new Audio(audioData);
            currentAudio = audio;
        
            const robotBtn = currentMode === 'pagele' ? 
                document.getElementById('robot-pagele') : 
                document.getElementById('robot');
                
            if (robotBtn) {
                robotBtn.setAttribute('data-speaking', 'true');
                robotBtn.style.filter = 'brightness(0.7)';
            }
        
            audio.onended = () => {
                console.log('Speech ended for:', textKeyForLog);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
        
            audio.onerror = (e) => {
                console.error('Speech error for:', textKeyForLog, e);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null;
            };
        
            audio.play().catch(e => {
                console.error('Error playing audio for:', textKeyForLog, e);
                if (robotBtn) {
                    robotBtn.setAttribute('data-speaking', 'false');
                    robotBtn.style.filter = 'brightness(1)';
                }
                currentAudio = null; 
            });
        }

        async function initiateTip(amount) {
            try {
                drawer.style.display = 'none';
                document.getElementById('payment-modal').style.display = 'block';
                sendSocketMessage({
                    task: 'tip',
                    amount: amount
                });
            } catch (error) {
                console.error('Error initiating tip:', error);
                alert('Error processing tip. Please try again.');
            }
        }

        // Function to send bug report with logs
        async function sendBugReport() {
            try {
                const foundBugBtn = document.getElementById('found-bug');
                const originalText = foundBugBtn.textContent;
                foundBugBtn.textContent = getInterfaceString('sendingBugReport');
                foundBugBtn.style.pointerEvents = 'none';
                
                // Gather system information
                const systemInfo = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    url: window.location.href,
                    timestamp: new Date().toISOString(),
                    currentMode: currentMode,
                    isLoggedIn: isLoggedIn,
                    username: userInfo.username || 'Not logged in',
                    selectedBook: selectedBook || 'None',
                    pageleFilename: pageleFilename || 'None'
                };

                // Process logs to shorten them
                const processedLogs = sessionLogs.map(logEntry => {
                    const processedEntry = { ...logEntry }; // Shallow copy

                    // Truncate message
                    if (typeof processedEntry.message === 'string' && processedEntry.message.length > 200) {
                        processedEntry.message = processedEntry.message.substring(0, 197) + "...";
                    }

                    // Process args
                    if (Array.isArray(processedEntry.args)) {
                        processedEntry.args = processedEntry.args.map(arg => {
                            if (typeof arg === 'string') {
                                if ((arg.startsWith('{') && arg.endsWith('}')) || (arg.startsWith('[') && arg.endsWith(']'))) {
                                    try {
                                        JSON.parse(arg); // Check if it's valid JSON
                                        if (arg.startsWith('{')) return "{JSON Object}";
                                        if (arg.startsWith('[')) return "[JSON Array]";
                                    } catch (e) {
                                        // Not valid JSON, treat as regular string
                                    }
                                }
                                if (arg.length > 100) {
                                    return arg.substring(0, 97) + "...";
                                }
                            } else if (typeof arg === 'object' && arg !== null) {
                                return Array.isArray(arg) ? "[Array]" : "[Object]";
                            }
                            return arg; // Keep numbers, booleans, etc. as is
                        });
                    }
                    return processedEntry;
                });
                
                // Format logs for email using processed logs
                const formattedLogs = processedLogs.map(log => 
                    `[${log.timestamp}] ${log.type.toUpperCase()}: ${log.message} ${log.args.join(' ')}`
                ).join('\\n');
                console.log("processedLogs for email: ", processedLogs);
                console.log("processedLogs length: ", processedLogs.length);
                
                const emailBody = `
Bug Report from Hablas App
==========================

System Information:
${JSON.stringify(systemInfo, null, 2)}

Session Logs:
${formattedLogs}

Additional Notes:
(User can add more details here)
                `.trim();
                
                // Send via WebSocket to your server using processed logs
                sendSocketMessage({
                    task: 'send_bug_report',
                    systemInfo: systemInfo,
                    logs: processedLogs, // Use processed logs
                    emailBody: emailBody, // emailBody is now generated from processed logs
                    token: localStorage.getItem('token')
                });
                
                // Reset button after a delay
                setTimeout(() => {
                    foundBugBtn.textContent = originalText;
                    foundBugBtn.style.pointerEvents = 'auto';
                    alert(getInterfaceString('bugReportSent'));
                    drawer.classList.remove('open');
                    setTimeout(() => {
                        drawer.style.display = 'none';
                    }, 300);
                }, 2000);
                
            } catch (error) {
                console.error('Error sending bug report:', error);
                const foundBugBtn = document.getElementById('found-bug');
                foundBugBtn.textContent = getInterfaceString('foundABug');
                foundBugBtn.style.pointerEvents = 'auto';
                alert(getInterfaceString('bugReportError'));
            }
        }

        // Event listeners
        window.addEventListener('DOMContentLoaded', () => {
            // Check for stored token and username
            const storedToken = localStorage.getItem('token');
            const storedUsername = localStorage.getItem('username');
            console.log("storedToken: ", storedToken);
            console.log("storedUsername: ", storedUsername);
            
            // Display initial choice with disabled buttons by default
            switchToMode('init');
            
            if (storedToken) {
                if (socket.readyState === WebSocket.OPEN) {
                    verifyToken(storedToken);
                } else {
                    socket.addEventListener('open', () => {
                        verifyToken(storedToken);
                    }, { once: true });
                }
            }else{
                console.log("no token");
            }

            // Set up all event listeners
            setupEventListeners();
            
            // Apply initial interface language
            applyInterfaceStrings(interfaceStrings.en);
        });

        function setupEventListeners() {
            // Close buttons
            const closeButtons = document.getElementsByClassName('close');
            Array.from(closeButtons).forEach(closeBtn => {
                closeBtn.addEventListener(EVENT_TYPE, () => {
                    const container = closeBtn.closest('.modal, .drawer, #books-modal');
                    console.log("closing container:", container);
                    if (container) {
                        container.style.display = 'none';
                    }
                });
            });

            // Close modal button for translation
            const closeModalBtn = document.querySelector('.close-modal');
            closeModalBtn.addEventListener(EVENT_TYPE, () => {
                modalDiv.style.display = "none";
                lineNum = 0;
                const pointsDisplay = document.getElementById('points-display');
                pointsDisplay.style.display = 'none';
            });

            // Login buttons
            loginButton.addEventListener(EVENT_TYPE, () => {
                loginButton.style.backgroundColor = '#FFB6C1';
                username = usernameInput.value.toLowerCase();
                password = passwordInput.value;

                if (!isValidEmail(username)) {
                    alert(getInterfaceString('enterValidEmail'));
                    return; 
                }

                if (!password || password.trim() === "") {
                    alert(getInterfaceString('passwordCannotBeEmpty'));
                    return; 
                }

                sendSocketMessage({
                    task: "login",
                    username: username,
                    password: password
                });
            });

            loginButton2.addEventListener(EVENT_TYPE, () => {
                loginButton2.style.backgroundColor = '#FFB6C1';
                
                username = usernameInput2.value.toLowerCase();
                password = passwordInput2.value;

                if (!isValidEmail(username)) {
                    alert("Please enter a valid email address");
                    return; 
                }

                if (!password || password.trim() === "") {
                    alert("Password cannot be empty");
                    return; 
                }

                sendSocketMessage({
                    task: "login",
                    username: username,
                    password: password
                });
            });

            // Signup buttons
            signupButton.addEventListener(EVENT_TYPE, () => {
                signupButton.style.backgroundColor = '#FFB6C1';
                username = usernameInput.value.toLowerCase();
                password = passwordInput.value;

                if (!isValidEmail(username)) {
                    alert("Please enter a valid email address");
                    return;
                }

                if (!password || password.trim() === "") {
                    alert("Password cannot be empty");
                    return;
                }

                sendSocketMessage({
                    task: "signup",
                    username: username,
                    password: password
                });
            });

            signupButton2.addEventListener(EVENT_TYPE, () => {
                signupButton2.style.backgroundColor = '#FFB6C1';
                username = usernameInput2.value.toLowerCase();
                password = passwordInput2.value;

                if (!isValidEmail(username)) {
                    alert("Please enter a valid email address");
                    return;
                }

                if (!password || password.trim() === "") {
                    alert("Password cannot be empty");
                    return;
                }

                sendSocketMessage({
                    task: "signup",
                    username: username,
                    password: password
                });
            });

            // Mode switching
            initDailypages.addEventListener(EVENT_TYPE, () => {
                if (!initDailypages.classList.contains('disabled')) {
                    logEvent('User switched to Daily Pages mode');
                    switchToMode('pagele');
                }
            });

            initFreeRead.addEventListener(EVENT_TYPE, () => {
                if (!initFreeRead.classList.contains('disabled')) {
                    logEvent('User switched to Free Read mode');
                    switchToMode('freeread');
                }
            });

            // Mode switch button in settings
            modeSwitch.addEventListener(EVENT_TYPE, () => {
                if (currentMode === 'freeread') {
                    switchToMode('pagele');
                } else if (currentMode === 'pagele') {
                    switchToMode('freeread');
                }
                drawer.classList.remove('open');
                setTimeout(() => {
                    drawer.style.display = 'none';
                }, 300);
            });

            // Settings drawer
            userSection.addEventListener(EVENT_TYPE, (event) => {
                if (userSection.textContent == "Login") {
                    console.log("user section clicked");
                    drawer.style.display = 'block';
                    setTimeout(() => {
                        drawer.classList.add('open');
                    }, 10);
                    event.stopPropagation();
                }
            });

            settingsBtn.addEventListener(EVENT_TYPE, (event) => {
                console.log("settings button clicked");
                drawer.style.display = 'block';
                setTimeout(() => {
                    drawer.classList.add('open');
                }, 10);
                event.stopPropagation();
            });

            closeDrawerBtn.addEventListener(EVENT_TYPE, () => {
                console.log("close button clicked");
                drawer.classList.remove('open');
                setTimeout(() => {
                    drawer.style.display = 'none';
                }, 300);
            });

            window.addEventListener(EVENT_TYPE, (event) => {
                if (!drawer.contains(event.target) && !settingsBtn.contains(event.target)) {
                    drawer.classList.remove('open');
                    setTimeout(() => {
                        drawer.style.display = 'none';
                    }, 300);
                }
            });

           

            // File input
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    try {
                        await renderEpub(file);
                    } catch (error) {
                        console.error('Error handling file:', error);
                    }
                }
            });

            fileDiv.addEventListener(EVENT_TYPE, () => {
                fileInput.click();
            });

            // Recording buttons
            recordBtn.addEventListener(EVENT_TYPE, async () => {
                let permissionResult = await navigator.permissions.query({ name: 'microphone' });
                console.log("permissionResult: ", permissionResult);

                if (permissionResult.state != 'granted') {
                    permissionResult = await navigator.permissions.query({ name: 'microphone' });
                    console.log("permissionResult: ", permissionResult);

                    alert('Please grant permission to access the microphone');
                    const streamPermission = await navigator.mediaDevices.getUserMedia({ audio: true });
                } else if (permissionResult.state == 'granted') {
                    console.log("permission granted");

                    if (!isRecording) {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        
                        mediaRecorder.ondataavailable = event => {
                            audioChunks.push(event.data);
                        };

                        mediaRecorder.start();
                        isRecording = true;
                        if (mediaRecorder.state === 'recording') {
                            console.log('Recording started successfully, this is the state: ', mediaRecorder.state);
                            recordBtn.src = "images/stopRecButton.png";
                        } else {
                            alert('Failed to start recording. Please try again.');
                            isRecording = false;
                            recordBtn.src = "images/recordingButton.png";
                        }
                    } else {
                        mediaRecorder.stop(); 
                        isRecording = false;
                        recordBtn.src = "images/recordingButton.png";
                    } 
                           
                    mediaRecorder.onstop = () => {
                        createBlobAndConnect();
                    };
                }
            });

            // Pagele recording button
            if (recordBtnPagele) {
                recordBtnPagele.addEventListener(EVENT_TYPE, async () => {
                    console.log("Recording button clicked (pagele)");
                    try {
                        let permissionResult = await navigator.permissions.query({ name: 'microphone' });
                        
                        if (permissionResult.state === 'granted' || permissionResult.state === 'prompt') {
                            if (!isRecording) {
                                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                                mediaRecorder = new MediaRecorder(stream);
                                
                                mediaRecorder.ondataavailable = event => {
                                    audioChunks.push(event.data);
                                };
                                
                                mediaRecorder.start();
                                isRecording = true;
                                if (mediaRecorder.state === 'recording') {
                                    console.log('Recording started successfully');
                                    recordBtnPagele.src = "images/stopRecButton.png";
                                } else {
                                    alert('Failed to start recording. Please try again.');
                                    isRecording = false;
                                    recordBtnPagele.src = "images/recordingButton.png";
                                }
                            } else {
                                mediaRecorder.stop();
                                isRecording = false;
                                recordBtnPagele.src = "images/recordingButton.png";
                            }
                            
                            mediaRecorder.onstop = () => {
                                createBlobAndConnect();
                            };
                        } else if (permissionResult.state === 'denied') {
                            alert('Microphone permission is required for recording.');
                        }
                    } catch (error) {
                        console.error('Error accessing microphone:', error);
                        alert('Could not access microphone. Please check your browser permissions.');
                    }
                });
            }

            // Text-to-speech buttons
            textToSpeechBtn.addEventListener(EVENT_TYPE, () => {
                const isCurrentlySpeaking = textToSpeechBtn.getAttribute('data-speaking') === 'true';
                
                if (isCurrentlySpeaking) {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio.currentTime = 0;
                        currentAudio = null;
                    }
                    
                    textToSpeechBtn.setAttribute('data-speaking', 'false');
                    textToSpeechBtn.style.filter = 'brightness(1)';
                } else {
                    textToSpeechBtn.setAttribute('data-speaking', 'true');
                    textToSpeechBtn.style.filter = 'brightness(0.7)';
                    textToSpeech(lines[lineNum]);
                }
            });

            if (robotBtnPagele) {
                robotBtnPagele.addEventListener(EVENT_TYPE, () => {
                    const isCurrentlySpeaking = robotBtnPagele.getAttribute('data-speaking') === 'true';
                    
                    if (isCurrentlySpeaking) {
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio.currentTime = 0;
                            currentAudio = null;
                        }
                        
                        robotBtnPagele.setAttribute('data-speaking', 'false');
                        robotBtnPagele.style.filter = 'brightness(1)';
                    } else {
                        const currentSentence = sentenceElem.textContent;
                        robotBtnPagele.setAttribute('data-speaking', 'true');
                        robotBtnPagele.style.filter = 'brightness(0.7)';
                        textToSpeech(currentSentence);
                    }
                });
            }

            // Pagele navigation buttons
            if (prevButton) {
                prevButton.addEventListener('click', showPreviousSentence);
            }
            
            if (nextButton) {
                nextButton.addEventListener('click', showNextSentence);
            }

            // Pagele modal close buttons
            if (closeSentenceModalBtn) {
                closeSentenceModalBtn.addEventListener('click', () => {
                    sentenceModal.style.display = 'none';
                    chaptersModal.style.display = 'block';
                });
            }

            if (closeChaptersModal) {
                closeChaptersModal.addEventListener('click', () => {
                    chaptersModal.style.display = 'none';
                    pageleModal.style.display = 'block';
                });
            }

            // Translation button (pagele)
            const translationBtn = document.getElementById('translation-btn');
            let originalSentence = '';
            
            if (translationBtn) {
                translationBtn.addEventListener('mousedown', handleTranslationStart);
                translationBtn.addEventListener('touchstart', handleTranslationStart);
                
                translationBtn.addEventListener('mouseup', handleTranslationEnd);
                translationBtn.addEventListener('touchend', handleTranslationEnd);
                translationBtn.addEventListener('mouseleave', handleTranslationEnd);
                
                function handleTranslationStart(e) {
                    console.log("translation start");
                    e.preventDefault();
                    translate_down = true;
                    originalSentence = sentenceElem.textContent;  
                    if (translated_text != "") {
                        sentenceElem.innerHTML = translated_text;
                    } else {
                        getTranslation(originalSentence);
                    }
                }
                
                function handleTranslationEnd() {
                    translate_down = false;
                    if (originalSentence) {
                        sentenceElem.textContent = originalSentence;
                    }
                }
                
                function getTranslation(text) {
                    sentenceElem.textContent = "Translating...";
                    console.log("userInfo: ");
                    console.log(userInfo);
                    
                    let userLang = userInfo.preferredLanguage || document.getElementById('languageUserOptions').value;
                    
                    if (userLang.length > 2) {
                        const lowerLang = userLang.toLowerCase();
                        if (lang_conversion[lowerLang]) {
                            userLang = lang_conversion[lowerLang];
                        }
                    }
                    
                    let sourceLang = pagele_language;
                    if (sourceLang && sourceLang.length > 2) {
                        const lowerSource = sourceLang.toLowerCase();
                        if (lang_conversion[lowerSource]) {
                            sourceLang = lang_conversion[lowerSource];
                        }
                    }
                    
                    console.log("Using language for translation from", sourceLang, "to", userLang);
                    console.log({
                        task: 'translate',
                        text: text,
                        source_lang: sourceLang,
                        target_lang: userLang
                    });
                    
                    sendSocketMessage({
                        task: 'translate',
                        text: text,
                        source_lang: sourceLang,
                        target_lang: userLang
                    });
                }
            }

            // Tutorial button
            tutorialBtn.addEventListener(EVENT_TYPE, () => {
                const tutorialModal = document.getElementById('tutorialModal');
                const tutorialContent = document.getElementById('tutorial-content');
                
                tutorialModal.style.display = "block";
                
                fetch('tutorial.html')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(html => {
                        tutorialContent.innerHTML = html;
                    })
                    .catch(error => {
                        console.error('Error loading tutorial:', error);
                        tutorialContent.innerHTML = `
                            <div style="text-align: center; padding: 20px;">
                                <h3>Error loading tutorial content</h3>
                                <p>Please try again later.</p>
                            </div>
                        `;
                    });
            });

            // Found a bug button
            const foundBugBtn = document.getElementById('found-bug');
            foundBugBtn.addEventListener(EVENT_TYPE, () => {
                sendBugReport();
            });

            // Tip buttons
            document.querySelectorAll('.tip-button').forEach(button => {
                button.addEventListener(EVENT_TYPE, async () => {
                    const amount = button.dataset.amount;
                    await initiateTip(amount);
                });
            });

            document.getElementById('custom-tip-button').addEventListener(EVENT_TYPE, async () => {
                const amount = document.getElementById('custom-tip').value;
                if (amount && amount > 0) {
                    await initiateTip(amount);
                } else {
                    alert(getInterfaceString('enterValidAmount'));
                }
            });

            // Global click handlers
            window.addEventListener(EVENT_TYPE, (event) => {
                if (event.target == modalDiv) {
                    modalDiv.style.display = "none";
                }
            });

            document.addEventListener(EVENT_TYPE, (event) => {
                const popups = document.querySelectorAll('.popup');
                if (popups.length > 0) {
                    const clickedInsidePopup = Array.from(popups).some(popup => popup.contains(event.target));
                    const clickedOnWrongElement = event.target.classList.contains('wrong');
                    const clickedOnPopupClose = event.target.classList.contains('popup-close');
                    
                    if (!clickedInsidePopup && !clickedOnWrongElement && !clickedOnPopupClose) {
                        popups.forEach(popup => popup.remove());
                        popupflag = false;
                    }
                }
            });

            // Language selection change handler
            languageUserOptionsSelect.addEventListener('change', (event) => {
                const selectedLang = event.target.value;
                console.log('Interface language changed to:', selectedLang);
                updateInterfaceLanguage(selectedLang);
                
                // Save user preference
                if (localStorage.getItem('token')) {
                    sendSocketMessage({
                        task: 'update_interface_language',
                        language: selectedLang,
                        token: localStorage.getItem('token')
                    });
                }
            });

            // Make sure the drawer starts hidden
            drawer.style.display = 'none';
        }

        // Call loadAvailableBooks when the available books button is clicked
availableBooksBtn.addEventListener(EVENT_TYPE, () => {
    loadAvailableBooks();
    drawer.classList.remove('open');
        setTimeout(() => {
            drawer.style.display = 'none';
        }, 300); 
    
});
availablePageleBtn.addEventListener(EVENT_TYPE, () => {
    switchToMode('pagele');
    drawer.classList.remove('open');
    setTimeout(() => {
        drawer.style.display = 'none';
    }, 300); 
});
    </script>
</body>
</html> 
